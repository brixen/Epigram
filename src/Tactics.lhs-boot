> {-# LANGUAGE TypeOperators, GADTs, KindSignatures, RankNTypes,
>     TypeSynonymInstances, FlexibleInstances, ScopedTypeVariables #-}


> module Tactics (Tac,                          -- abstract Tactic
>                 runTac,                       -- run tactics
>                 goal, subgoal, discharge,     -- low-level combinators
>                 lambda, can,                  -- introduction rules
>                 done, use, useOp, apply,      -- elimination rules
>                 tyLambda, infr, chk, useTac,  -- out of context
>                 switch, cases,                -- dealing with Enum
>                 split,                        -- dealing with Sigma		  	 
>		  foldDesc,                     -- dealing with Desc
>                 trustMe                       -- build terms
>                 ) where

> import Tm
> import Root
> import Rooty

> data Tac x

> instance Monad Tac

> runTac :: Tac x -> Root -> TY -> Either [String] x


> goal :: Tac TY
> subgoal :: (TY :>: Tac x) -> Tac x

> discharge :: Rooty m => REF -> VAL -> m VAL
> lambda :: (REF -> Tac VAL) -> Tac VAL
> can :: Can (Tac VAL) -> Tac VAL

> type Use = (VAL :<: TY) -> Tac VAL

> done :: Use
> apply :: Elim (Tac VAL) -> Use -> Use
> use :: REF -> Use -> Tac VAL
> useOp :: Op -> [Tac VAL] -> Use -> Tac VAL

> switch :: Tac VAL -> Tac VAL
> cases :: [Tac VAL] -> Tac VAL

> split :: Tac VAL -> Tac VAL

> tyLambda :: (String :<: TY) -> (REF -> Tac (VAL :<: TY))
>                             -> Tac (VAL :<: TY)
> infr :: (TY :>: Tac VAL) -> Tac (VAL :<: TY)
> chk :: Tac (VAL :<: TY) -> Tac VAL
> useTac :: Tac (VAL :<: TY) -> Elim (Tac VAL)
>                            -> Tac (VAL :<: TY)

> foldDesc :: Tac VAL -> Tac VAL

> trustMe :: (TY :>: Tac VAL) -> VAL