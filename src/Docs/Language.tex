\section{Language}


\newcommand{\SC}{\textsc}
\newcommand{\lgb}{\langle}
\newcommand{\rgb}{\rangle}
\newcommand{\gb}[1]{\left<{#1}\right>}
\[
\begin{array}{rll}
\SC{InTm} ::= & \verb!*! 
                & \mbox{Set} \\
            | & \lgb\verb!(!\SC{Nom}\verb! : !\SC{InTm} \verb!)!\rgb^+\verb! -> ! \SC{InTm} 
                & \mbox{\(\Pi\)-type} \\
            | & \SC{InTm} \verb! -> ! \SC{InTm}  
                & \mbox{nondependent function type} \\
            | & \verb!\! \SC{Nom}^* \verb! -> ! \SC{InTm} 
                & \mbox{\(\lambda\)-abstraction} \\
            | & \verb!#! 
                & \mbox{Prop} \\
            | & \verb!:- ! \SC{InTm} 
                & \mbox{set of proofs} \\
            | & \SC{NAT} \lgb\verb!+ ! \SC{InTm}\rgb^? 
                & \mbox{Integers} \\
            | & \verb!@! \SC{InTm} 
                & \mbox{Con for inductive definitions} \\
            | & \verb!(!\SC{Sig}\verb!)! 
                & \mbox{`record' signature} \\
            | & \verb![]! 
                & \mbox{void} \\
            | & \verb![!\SC{InTm}^+\:\lgb\verb!/ !\SC{InTm}\rgb^?\verb!]! 
                & \mbox{tuple} \\
            | & \verb!{!\SC{Nom}^{\verb!,!*}\:\lgb\verb!/ !\SC{InTm}\rgb^?\verb!}! 
                & \mbox{enumeration} \\
            | & \lgb\verb!(!\SC{Nom}\verb! : !\SC{InTm} \verb!)!\rgb^+\verb! => ! \SC{InTm} 
                & \mbox{propositional \(\forall\)} \\
            | & \SC{InTm} \verb! && ! \SC{InTm} 
                & \mbox{propositional And} \\
            | & \verb!TT ! | \verb| FF|
                & \mbox{propositional Trivial and Absurd} \\
            | & \verb!(!\SC{InTm}\verb! : !\SC{InTm}\verb!)! \verb! == ! \verb!(!\SC{InTm}\verb! : !\SC{InTm}\verb!)! 
                & \mbox{blue equality} \\
            | & \verb!(!\SC{InTm}\verb!)! 
                & \mbox{grouping} \\
            | & \SC{ExTm} 
                & \mbox{term with synthesizable type} \medskip \\
\SC{Sig} ::= & \varepsilon & \mbox{unit signature} \\
           | & \lgb\SC{Nom}\verb! : !\rgb^? \SC{InTm}\:
               \lgb\verb!; !|\verb! :- !\rgb \lgb\SC{InTm}|\SC{Sig}\rgb
                  & \mbox{\(\Sigma\)-type} \medskip \\
\SC{ExTm} ::= & \SC{InTm}\verb! : !\SC{InTm} 
                & \\
            | & \SC{Nom}\lgb\verb!^!\SC{Nat}\rgb^? \lgb \verb!.! \SC{Nom} \lgb\verb!^!\SC{Nat}\rgb^? \rgb^*
                & \\
            | & \SC{ExTm}\:\SC{InTm} 
                & \\
            | & \SC{ExTm}\:\verb|!| 
                & \mbox{car} \\
            | & \SC{ExTm}\:\verb!-! 
                & \mbox{cdr} \\
            | & \SC{Op}\verb!(!\SC{InTm}^{\verb!,!*}\verb!)! 
                & \mbox{operator} \\
            | & \verb!(!\SC{InTm}\verb! : !\SC{InTm}\verb!)!  \verb! <-> ! \verb!(!\SC{InTm}\verb! : !\SC{InTm}\verb!)! 
                & \mbox{green equality} \\
\end{array}
\]
  
and more to come. For developments:

\[
\begin{array}{rll}
\SC{Top} ::= & \lgb \verb![! \SC{Girl}^* \verb!]! \rgb^? \SC{Com}^{\verb!;!*} 
               & \mbox{top-level development} \\

\SC{Girl} ::= & \SC{Nom} \lgb \verb![! \SC{Line}^* \verb!]! | \verb!:=!  \rgb \lgb \verb!?! | \SC{InTm} \rgb \verb!:! \SC{InTm} \lgb \verb![| ! \SC{Com}^{\verb!;!*} \verb! |]! \rgb^? \verb! ;!
               & \mbox{development} \\

\SC{Line} ::= & \SC{Girl} | \SC{Boy}
                 & \mbox{line in development} \\

\SC{Boy} ::= & \verb!\! \SC{Nom} \verb!:! \SC{InTm} \verb! ->!
               & \mbox{$\lambda$-boy} \\
           | & \verb!(! \SC{Nom} \verb!:! \SC{InTm} \verb!) ->!
               & \mbox{$\Pi$-boy} \\
           | & \verb!(! \SC{Nom} \verb!:! \SC{InTm} \verb!;) ->!
               & \mbox{$\Sigma$-boy} \\
           | & \verb!:- (! \SC{Nom} \verb!:! \SC{InTm} \verb!) =>!
               & \mbox{$\forall$-boy} \\

\end{array}
\]


\begin{itemize}
\item \verb!*! for the universe of sets
\item \verb!#! for the universe of propositions
\item \verb|()| for the unit type
\item \verb!\ x -> t! for the $\lambda$-term $\lambda x.t$
\item \verb|f a| for $f$ applied to $a$ (no surprises here)
\item \verb!(x : S) -> T! for the $\Pi$-type $\Pi x:S. T$
\item \verb!S -> T! for the same $\Pi$-type if $T$ is independent of $x$
\item \verb!(x : S)(y : T) -> U! for the nested $\Pi$-type $\Pi x:S. \Pi y:T. U$
\item \verb!{| P}! for the type of proofs of $P$ (cf.\ set notation)
\item \verb!{x : S | P}! for the $\Sigma$-type $\Sigma x:S. P$
\item \verb!{x : S, y : T | P}! for the nested $\Sigma$-type $\Sigma x:S. \Sigma y:T. P$
\item \verb![a, b, c]! for the tuple $(a, (b, (c, ())))$ (think LISP lists)
\item \verb![a, c, c |]! for the tuple $(a, (b, c))$ (maybe?)
\item \verb!Enum! for the universe of enumerations
\item \verb!{}! for the empty enumerated type
\item \verb!{x, y, z}! for an enumerated type
\item \verb!0, 1, 2, ...! for \verb!zero!, \verb!suc zero!, \verb!suc (suc zero)!, et cetera
\item \verb!2 + tm! for \verb!suc (suc tm)!
\item \verb!@id! for a tag
\item \verb!F(..., ...)! for a fully applied operator
\end{itemize}

\question{Does this notation for $\Sigma$-types make sense, or should we go with the
original proposal of using an ampersand?}

\question{Perhaps we could use $[a, b, c, ]$ with a trailing comma to mean
$(a, (b, c))$? Using a vertical bar is problematic because it clashes with the
``such that'' interpretation.}

This is all very tenative. One overriding principle is that we should stick to ASCII
characters throughout. Users may use Unicode if they wish, but it should not be
forced upon them.
