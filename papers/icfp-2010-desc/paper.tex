\documentclass[preprint
              , authoryear
%              , onecolumn
              ]{sigplanconf}

\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{pig}

\include{macros}

%% Structure
\newenvironment{structure}{\footnotesize\verbatim}{\endverbatim}
%\newenvironment{structure}{\comment}{\endcomment}

%% Written bits of Structure
\newenvironment{wstructure}{\comment}{\endcomment}

%% Comments
\setlength{\marginparwidth}{0.7in}
\newcommand{\note}[1]{\-\marginpar[\raggedright\footnotesize #1]%
                                  {\raggedright\footnotesize #1}}

%% Syntax
\newcommand{\bind}{\emph{bind}}
\newcommand{\return}{\emph{return}}

\begin{document}

\ColourEpigram

%\conferenceinfo{WXYZ '05}{date, City.} 
%\copyrightyear{2005} 
%\copyrightdata{[to be supplied]} 

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Title
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\title{The Gentle Art of Levitation}


%% Alphabetical ordering.
\authorinfo{James Chapman}
           {Institute of Cybernetics, Tallinn University of Technology}
           {james@cs.ioc.ee}
\authorinfo{Pierre-\'{E}variste Dagand \\ Conor McBride}
           {University of Strathclyde}
           {\{dagand,conor\}@cis.strath.ac.uk}
\authorinfo{Peter Morris}
           {University of Nottingham}
           {pwm@cs.nott.ac.uk}


\maketitle


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Abstract
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{abstract}
This is the text of the abstract.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}

%\terms
%term1, term2

%\keywords
%keyword1, keyword2





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

Dependent types are an appealing technique for building safer and more
reliable software. By giving types more expressive power, the
developer is able to encode more precise invariants in the types. As a
result, more bugs are caught automatically, during
type-checking. Because of this benefit, dependently-typed systems have
flourished, such as Generalized Abstract Data-Types (GADT) in
Haskell~\cite{spj:gadt}, Agda~\cite{norell:agda},
Ynot~\cite{morrisett:ynot}, or Epigram~\cite{pigs:epigram}, to name
but a few.

\begin{wstructure}
<- Describe the problem
    <- Data-types in dependent-type theory
        <- Much more precise
            <- More powerful type-system
            -> Stronger safety guarantees
\end{wstructure}

In this paper, we will focus on data-types in such systems. Indeed,
the expressive power of the type-system has a direct impact on
data-types. Because types can \emph{depend} on terms, our data-types
can be made more precise. The typical example is vectors, which type
depend on the size of the vector. Having more precision about
data-types, we can write safer code: taking the $\CN{head}$ of a
vector is \emph{ensured} to succeed whenever its type states that it
is a non-empty vector. This property is automatically enforced by the
type-checker.

\begin{wstructure}
        <- Equipped with elimination principle
            <- Defining functions over them
            <- Making proofs over them
\end{wstructure}

Moreover, in total programming systems, such as Agda, Ynot, or
Epigram, data-types come equipped with an elimination principle: while
a data-type definition introduces new type formers in the theory, we
need an eliminator to dispose of them. Looking through the
Curry-Howard lenses, the elimination principle corresponds to an
induction principle associated with the data-type. To program over our
data-types, we rely on their induction principle, guaranteeing the
well-foundedness of our definition.

\begin{wstructure}
    <- Agda standard library [Nisse file]
        <- x implementations of natural numbers
        <- y implementations of lists
        -> Painful duplication of code and functionality
            <- Types are (slightly) different
                -> Same functions need to be re-implemented 
        -> Crucial need for ``genericity''
\end{wstructure}

From a software correctness point of view, having fine-grained types
is a blessing. However, from a software re-use point of view, this is
a major hurdle. For example, the difference between lists and vectors
is rather thin, and, for most functions, it does not make a
difference. However, because their type is (slightly) different, the
functions need to be implemented separately. Often, the code will even
be the same, only the type signature changes. A striking example of
such unavoidable code duplication is apparent in the Agda standard
library~\cite{nisse:asl}: it features no less than 13 variations of
lists, ranging from difference lists to lists which elements verify
some predicate. In dependently-typed system, we crucially need to
program \emph{generically}.

\begin{wstructure}
        /> Coq, Agda: external notion
            <- Not first-class citizen
            -> Cannot "compute" with them
            -> No reflection for data-types (?)
\end{wstructure}

While central in a programming environment, the presentation of
data-types in today's dependently-typed system is
\emph{external}. As in the simply-typed world, the definition of
data-types is processed by a meta-theoretical engine, before being
reifed by extending the type theory with the corresponding type
formers and elimination principle. Because of this external apparatus,
data-type definition is not \emph{first-class}: we cannot compute with
them, such as making new data-types from previous data-types. 

This is a rather harsh limitation, in particular in a
dependently-typed system. Indeed, reflection~\cite{allen:reflection,
  gregoire:ring-solver} is at the heart of many dependently-typed
programming techniques. Not having first-class data-type definitions,
we have to give up reflection for data-types.

\begin{wstructure}
    <- Dependent types offer new programming techniques
        <- Eg.: universe construction
        /> State of the art haunted by the simply-typed paradigm
            -> Generative
            -> Non reflective
\end{wstructure}

However, we do not think that we are condemned to such fate. The
external presentation of data-types is an heritage of the simply-typed
paradigm. Dependently-typed system has more to offer. Indeed, new
programming techniques, unavailable in a simply-typed setting,
arises. One of them is \emph{universe
  construction}~\cite{martin-lof:itt}. We shall see how this technique
help us overcoming the limitations of the standard, non reflective and
generative presentation of data-types.

\begin{wstructure}
<- State contributions
    <- Closed presentation of data-types 
        -> No generativity requires
        -> Subsuming standard inductive families 
            /> Some popular extensions excluded for now
    <- Descriptions of data-types are first-class 
        <- Self-encoded [Section sec:desc-levitate]
    <- ``generic programming is just programming''
        <- Ability to inspect data-type definition
            -> Write program over them
        <- A generic program works over a class of data-types (???)
            -> Capture this class by common structure
            -> Write a program over this common code
    <- Design a language for generic programming
        -> First serious attempt
            /> except possibly Lisp
                <- ???
\end{wstructure}

In this paper, we propose a new approach to build data-types in a
dependent-type theory. Our contributions are the following:

\begin{itemize}
\item We present a basic type-theory and extend it with a universe of
  finite sets. We show how coding can be made practical by putting
  types at work (Section~\ref{sec:type-theory}) ;
\item We give a closed presentation of inductive data-types, through a
  universe of descriptions (Section~\ref{sec:universe-desc}). This
  first universe has the expressive power of standard inductive
  types. Being closed, this presentation does not require
  generativity, hence the type theory remains unchanged when
  data-types are introduced ;
\item We present a self-encoding of the universe of description inside
  itself (Section~\ref{sec:desc-levitate}). As a consequence,
  description of data-types appears as first-class object in the type
  theory. We illustrate the benefit of a first-order presentation by
  implementing a generic catamorphism as well as a generic free monad
  construction, together with its monadic operations ;
\item We index the universe of descriptions, to subsume standard
  inductive families (Section~\ref{sec:indexing-desc}). In this
  setting, we develop several examples of dependently-typed
  data-structure and some generic operations over them ;
\item We have implemented this technology in the Epigram programming
  language. This is, we believe, the first attempt to design a
  language for generic programming, Lisp having opened the way. We
  propose and demonstrate with several examples that generic
  programming is just programming. Because data-types are described by
  code, we can finally program with them. As a consequence, generic
  programs are implemented as functions built from the data-type
  definition.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% The Type Theory
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{paper_type_theory}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% A Universe of simple data-types
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{paper_desc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Levitating the universe of descriptions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{paper_desc_levitation}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Indexing descriptions
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{paper_idesc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Discussion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{paper_discussion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Conclusion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion}

\begin{wstructure}
<- System developed in a reasonable theory
    <- Pi, Sigma, Finite sets
    /> No assumption about the equality
    -> Low requirement / high applicability
\end{wstructure}

In this paper, we have presented a universe of data-types for a
dependently-typed language. To ensure the generality of our proposal,
this system has been presented in a reasonable type theory: our model
is composed of $\Pi$ and $\Sigma$-types, together with finite sets. In
particular, we have made no assumption about the underlying
propositional equality. Hence, our proposal can be applied in various
settings.

\begin{wstructure}
<- Formalize a rationnalized presentation of types
    <- Working directly with codes is not practical
    -> Bidirectional type-checking
        <- Type information flows during type checking/type synthesis
        -> Elaboration turns high-level expressions to low-level terms
    -> Should not be afraid by codes
\end{wstructure}

Because our approach is extensively using codes for universes, we give
a rationalised presentation of codes. By adapting bidirectional
type-checking to our setting, we are able to tame the verbosity of
codes. The distinction between type checking and type synthesis builds
a \emph{type propagation} system. The developer is thus able to write
convenient, high-level expressions that are elaborated into low-level
terms in the type theory. By adapting this technology to our
universes, we make practical the usage of codes for data-types.

\begin{wstructure}
<- Dependently-typed presentation of simple inductive types
    <- Universe of descriptions
        <- Based on the specificity of dependent types
            <- Universe of codes
            <- Sigma types
        -> External fix-point and generic induction scheme
    <- Rationalised by type propagation
        -> Developer does not see the code
    <- Self-describing
        <- Step-by-step exposition
        -> Minimal extension to the type theory
            <- Just need fix-point and induction
        -> Closed presentation of data-type
            -> Non generative
        -> Data-type is just data
    <- Generic programming is just programming
        <- Generic catamorphism
        <- Generic free monad
\end{wstructure}

To introduce our approach, we have presented a universe of
description. This universe has the expressive power of simple
inductive types, as we can find them in simply typed languages. This
technique relies on two key particularities of dependent types:
universe construction and sigma types. Going one step further, we
present an implementation of this universe as a self-described
object. Hence, for a minimal extension of the type-theory, we get a
closed presentation of data-types, where data-types are just data.

\begin{wstructure}
<- Indexed descriptions for dependent data-types
    <- Presented as a slight generalisation of Desc
        <- Just add indexing
    <- Develop several examples of data-types
        <- Typed syntax
        <- Constrained data-type a la GADT
    <- Generic indexed programming
        <- Indexed free monad
        <- Substitution
\end{wstructure}

To model dependent data-types, we generalise our presentation to
support indexing. The universe of indexed descriptions thus built
encompass inductive families. Again, this universe is
self-described. Moreover, we develop several examples of dependent
data-types and some generic functions over them.

\begin{wstructure}
<- All of this without cheating
    <- Admit a correct stratification
    <- Terminating
    <- Strictly-positive types
\end{wstructure}

We have presented a self-describing, self-hosted universe for
data-types. We have shown the benefit of such approach, as we are able
to reflect data-types in our type-theory. This fosters a new way of
considering generic programming: just as programming. Moreover,
despite its egg-and-chicken nature, this presentation does not suffer
from a paradox: it has been formalised in Agda, admitting a correct
stratification, using only terminating functions, and strictly
positive data-types.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Appendices
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \appendix
% \section{Appendix Title}

% This is the text of the appendix, if you need one.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Acknowledgments
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \acks

% Acknowledgments, if needed.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Bibliography
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\bibliography{paper}
\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.
%\begin{thebibliography}{}
%\softraggedright
%\end{thebibliography}

\end{document}
