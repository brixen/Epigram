\documentclass[preprint, authoryear, onecolumn]{sigplanconf}

\usepackage{amsmath}
\usepackage{verbatim}
\usepackage{pig}

\include{macros}

%% Structure
\newenvironment{structure}{\footnotesize\verbatim}{\endverbatim}
%\newenvironment{structure}{\comment}{\endcomment}


\begin{document}

\ColourEpigram

%\conferenceinfo{WXYZ '05}{date, City.} 
%\copyrightyear{2005} 
%\copyrightdata{[to be supplied]} 

%\titlebanner{banner above paper title}        % These are ignored unless
%\preprintfooter{short description of paper}   % 'preprint' option specified.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Title
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\title{The Gentle Art of Levitation}
% Or something mentionning levitation. Feel free to change. 
% \subtitle{Subtitle Text, if any}


%% Alphabetical ordering.
\authorinfo{James Chapman}
           {Institute of Cybernetics, Tallinn University of Technology}
           {james@cs.ioc.ee}
\authorinfo{Pierre-\'{E}variste Dagand \\ Conor McBride}
           {University of Strathclyde}
           {\{dagand,conor\}@cis.strath.ac.uk}
\authorinfo{Peter Morris}
           {University of Nottingham}
           {pwm@cs.nott.ac.uk}


\maketitle


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Abstract
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{abstract}
This is the text of the abstract.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}

%\terms
%term1, term2

%\keywords
%keyword1, keyword2





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Introduction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

The text of the paper begins here. \cite{morris:spf}

ACM bullet points, we offer:
\begin{itemize}
\item a closed presentation of data-types (no generativity requires)
  subsuming standard inductive families (some popular extensions
  excluded for now)
\item descriptions of data-types are first-class (indeed,
  self-encoded)
\item ``generic programming is just programming''
\item first serious attempt to design a language for generic
  programming, except possibly Lisp
\end{itemize}

\begin{structure}
<- presentation of the Core theory
    -> judgemental equality (extensional (a la OTT?))
    /> not Epigram specific 
        <- having OTT just buys you more stuffs
\end{structure}


\subsection{Base theory}

\begin{structure}
<- Base theory is:
    <- Pi, Sigma, Prop, True, Prf
<- Make it as standard as possible
    -> Avoid waste of space
\end{structure}

\[
\begin{array}{ll}
\Gamma\vdash\Valid & \mbox{\(\Gamma\) is a valid context, giving types to
                    variables} \\
\Gamma\vdash \Bhab{t}{T} & \mbox{term \(t\) has type \(T\) in context \(\Gamma\)} \\
\Gamma\vdash \Bhab{s \equiv t}{T} & \mbox{\(s\) and \(t\) are equal at type \(T\)
   in context \(\Gamma\)} \\
\end{array}
\]

The systems of inference rules will be formulated to ensure that that the
following implications always hold by induction on derivations.
\[
\begin{array}{l@{\;\;\Rightarrow\;\;}l}
\Gamma\vdash \Bhab{t}{T}            & \Gamma\vdash\Valid \;\wedge\; \Gamma\vdash\Type{T} \\
\Gamma\vdash s \equiv \Bhab{t}{T}   & \Gamma\vdash \Bhab{s}{T} \;\wedge\; \Gamma\vdash \Bhab{t}{T} \\
\Gamma;\xS;\Delta \vdash J          & \Gamma\vdash \Bhab{s}{S} \;\Rightarrow\; 
                                           \Gamma;\Delta[s/x] \vdash J[s/x] \\
\end{array}
\]


\begin{figure}

\[
%% Empty context validity
\Axiom{\vdash \Valid}
\qquad
%% Extend context
\Rule{\Gamma       \vdash \Type{S}}
     {\Gamma ; \xS \vdash \Valid}\;x\not\in\Gamma
\]

\caption{Context validity}
\label{fig:context-validity}
\end{figure}


\begin{figure}

\[\stkc{
%% Girard's favorite
\Rule{\Gamma \vdash \Valid}
     {\Gamma \vdash \Type{\Set}}
\qquad
%% Pi-Sigma
\Rule{\Gamma       \vdash \Type{S} \quad
      \Gamma ; \xS \vdash \Type{T}}
     {\Gamma \vdash \Type{\PIS{\xS} T, \SIGMAS{\xS} T}}
\\
%% Prop
\Rule{\Gamma \vdash \Bhab{q}{\Prop}}
     {\Gamma \vdash \Type{\prf{q}}}
\qquad
%% True
\Rule{\Gamma \vdash \Valid}
     {\Gamma \vdash \Bhab{\True}{\Prop}}
\\
%% Context
\Rule{\Gamma ; \xS ; \Delta \vdash \Valid}
     {\Gamma ; \xS ; \Delta \vdash \Bhab{x}{S}}
\qquad
%% Conversion
\Rule{\Gamma \vdash \Bhab{s}{S} \quad 
      \Gamma \vdash \Type{S \equiv T}}
     {\Gamma \vdash \Bhab{s}{T}}
\\
%% Lambda
\Rule{\stkl{\Gamma       \vdash \Type{S} \\
            \Gamma ; \xS \vdash \Bhab{t}{T}}}
     {\Gamma \vdash \Bhab{\PLAM{\x}{S} t}{\PIS{\xS} T}}
\qquad
%% Application
\Rule{\stkl{\Gamma \vdash \Bhab{f}{\PIS{\xS} T} \\
            \Gamma \vdash \Bhab{s}{S}}}
     {\Gamma \vdash \Bhab{f\: s}{T[s/x]}} 
\\
%% Pair
\Rule{\Gamma       \vdash \Bhab{s}{S} \quad 
      \Gamma ; \xS \vdash \Bhab{T}{\Set}    \quad
      \Gamma       \vdash \Bhab{t}{T[s/x]}}
     {\Gamma \vdash \Bhab{\pair{s}{t}{x.T}}{\SIGMAS{\xS} T}}
\\
%% First projection
\Rule{\Gamma \vdash \Bhab{p}{\SIGMAS{\xS} T}}
     {\Gamma \vdash \Bhab{\fst{p}}{S}} 
\qquad
%% Second projection
\Rule{\Gamma \vdash \Bhab{p}{\SIGMAS{\xS} T}}
     {\Gamma \vdash \Bhab{\snd{p}}{T[\fst{p}/x]}}
\\
}\]

\caption{Typing judgements}
\label{fig:typing-judgements}

\end{figure}

\begin{figure}

\[\stkc{
%% Beta-reduction
\Rule{\stkl{\Gamma       \vdash \Type{S} \quad
            \Gamma ; \xS \vdash \Bhab{t}{T} \\
            \Gamma       \vdash \Bhab{s}{S}}}
     {\Gamma \vdash \Bhab{(\PLAM{\x}{S} t)\:s \equiv t[s/x]}{T[s/x]}}
\\
%% Eta-reduction
\Rule{\Gamma       \vdash \Type{S} \quad
      \Gamma ; \xS \vdash \Bhab{f \equiv g}{T}}
     {\Gamma \vdash \Bhab{(\PLAM{\x}{S} f) \equiv (\PLAM{\x}{S} g)}{\PIS{\xS} T}}
\\
%% Projections
\Rule{\stkl{\Gamma                 \vdash \Bhab{s}{S} \quad
            \Gamma ; \xS           \vdash \Bhab{T}{\Set} \\
            \Gamma ; \Bhab{s}{S}   \vdash \Bhab{t}{T[s/x]}}}
     {\Gamma \vdash \Bhab{\fst{(\pair{s}{t}{T})} \equiv s}{S}}
\qquad
\Rule{\stkl{\Gamma               \vdash \Bhab{s}{S} \quad
            \Gamma ; \xS         \vdash \Bhab{T}{\Set} \\
            \Gamma ; \Bhab{s}{S} \vdash \Bhab{t}{T[s/x]}}}
     {\Gamma \vdash \Bhab{\snd{(\pair{s}{t}{T})} \equiv t}{T[s/x]}}
}\]

\caption{Judgemental equality}
\label{fig:judgemental-equality}

\end{figure}


\subsection{Enumerations}

\begin{structure}
<- Introduce Enumerations straight-away
    <- We need it all over the place
    <- See next section: Type propagation
        -> Nice appetizer 
\end{structure}

\begin{figure}

\[\stkc{
%% UId
\Rule{\Gamma \vdash \Valid}
     {\Gamma \vdash \Type{\UId}}
\qquad
%% Tag
\Rule{\Gamma \vdash \Valid}
     {\Gamma \vdash \Bhab{\Tag{s}}{\UId}}\;s \mbox{ unique identifier}
\\
%% EnumU
\Rule{\Gamma \vdash \Valid}
     {\Gamma \vdash \Type{\EnumU}} 
\qquad
%% EnumT
\Rule{\Gamma \vdash \Bhab{e}{\EnumU}}
     {\Gamma \vdash \Type{\EnumT{e}}} 
\\
%% NilE
\Rule{\Gamma \vdash \Valid}
     {\Gamma \vdash \Bhab{\NilE}{\EnumU}} 
\qquad
%% ConsE
\Rule{\Gamma \vdash \Bhab{t}{\UId} \quad
      \Gamma \vdash \Bhab{e}{\EnumU}}
     {\Gamma \vdash \Bhab{\ConsE{t}{e}}{\EnumU}}
\\
%% Ze
\Rule{\Gamma \vdash \Valid}
     {\Gamma \vdash \Bhab{\Ze}{\EnumT{\ConsE{t}{e}}}} 
\qquad
%% Su
\Rule{\Gamma \vdash \Bhab{n}{\EnumT{e}}}
     {\Gamma \vdash \Bhab{\Su{n}}{\EnumT{\ConsE{t}{e}}}}
}\]

\caption{Typing rules for finite sets}
\label{fig:typing-finite-set}

\end{figure}

\begin{figure}

\[\stkl{
%% spi
\F{$\pi$} : \PITEL{\V{e}}{\EnumU}
            \PITEL{\V{P}}{\EnumT{e} \To \Set} \To \Set 
\\
%% switch
\begin{array}{@{}ll}
\F{switch} : & \PITEL{\V{e}}{\EnumU}
               \PITEL{\V{P}}{\EnumT{e} \To \Set} \\
             & \PITEL{\V{b}}{\spi{e}{P}}
               \PITEL{\V{x}}{\EnumT{e}} \To P~x
\end{array}
}\]

\caption{Operators on finite sets}
\label{fig:operator-finite-set}

\end{figure}

\subsection{Type propagation}

\begin{structure}
<- Bidirectional basics
    -> Show how we can *infer* stuffs 
        <- Propagation of type information
    <- (A stripped-down version of Elaboration)
<- Examples:
    -> Propagation for tags
    -> Propagation for switch
\end{structure}


\begin{figure}

\[\stkc{
%% Form
\boxed{\Gamma \Vdash \propag{\push{\CN{exprIn}}{\CN{type}}}{\CN{term}}} 
\\
\\
%% Set in Set
%% \Axiom{\Gamma \Vdash \propag{\push{\Set}{\Set}}
%%                             {\Set}}
%% \\
%% Prop
%% \Rule{\Gamma \Vdash \propag{\push{q}{\Prop}}
%%                            {q'}}
%%      {\Gamma \Vdash \propag{\push{\prf{q}}{\Set}}
%%                            {\prf{q'}}}
%% \qquad
%% True
%% \Axiom{\Gamma \Vdash \propag{\push{\True}{\Prop}}
%%                             {\True}}
%% \\
%% Pi
%% \Rule{\Gamma \Vdash \propag{\push{S}{\Set}}
%%                            {S'} \quad
%%       \Gamma \Vdash \propag{\push{T}{S' \To \Set}}
%%                            {T'}}
%%      {\Gamma \Vdash \propag{\push{\PiTy{S}{T}}{\Set}}
%%                            {\PiTy{S'}{T'}}} 
%% \\
%% %% Sigma
%% \Rule{\Gamma \Vdash \propag{\push{S}{\Set}}
%%                            {S'} \quad
%%       \Gamma \Vdash \propag{\push{T}{S' \To \Set}}
%%                            {T'}}
%%      {\Gamma \Vdash \propag{\push{\SigmaTy{S}{T}}{\Set}}
%%                            {\SigmaTy{S'}{T'}}}
%% \\
%% Lambda
\Rule{\Gamma ; \xS \Vdash \propag{\push{t}{T\: x}}
                                 {t'}}
     {\Gamma \Vdash \propag{\push{\LAM{\x} t}{\PiTy{S}{T}}}
                           {\PLAM{\x}{S} t'}} 
\\
%% Pair
\Rule{\stkl{ \Gamma \Vdash \propag{\push{s}{S}}
                                  {s'} \\
             \Gamma \Vdash \propag{\push{t}{T\: s'}}
                                  {t'}}}
     {\Gamma \Vdash \propag{\push{\pair{s}{t}{}}{\SigmaTy{S}{T}}}
                           {\pair{s'}{t'}{T}}}
\\
%% EnumU
%% \Axiom{\Gamma \Vdash \propag{\push{\EnumU}{\Set}}
%%                             {\EnumU}} 
%% \qquad
%% %% EnumT
%% \Rule{\Gamma \Vdash \propag{\push{e}{\EnumU}}
%%                            {e'}}
%%      {\Gamma \Vdash \propag{\push{\EnumT{e}}{\Set}}
%%                            {\EnumT{e'}}}
%% \\
%% Tag
\Axiom{\Gamma \Vdash \propag{\push{\etag{t}}{\EnumT{\ConsE{t'}{e}}}}
                            {\Ze}}\;t = t'
\\
\Rule{\Gamma \Vdash \propag{\push{\etag{t}}{\EnumT{e}}}
                           {n}}
     {\Gamma \Vdash \propag{\push{\etag{t}}{\EnumT{\ConsE{t'}{e}}}}
                            {\Su{n}}}\;t \neq t'
\\
%% EnumU
\Axiom{\Gamma \Vdash \propag{\push{\Enum []}{\EnumU}}
                            {\NilE}}
\\
\Rule{\Gamma \Vdash \propag{\push{\Enum [ ts ]}{\EnumU}}
                                 {cs}}
     {\Gamma \Vdash \propag{\push{\Enum [ \etag{t_1}\:\: ts ]}{\EnumU}}
                                 {\ConsE{t_1}{cs}}}
\\
%% Switch
\Rule{\Gamma \Vdash \propag{\push{t}{\spi{e}{P}}}
                           {t'}}
     {\Gamma \Vdash \begin{array}{@{}l} 
                        \propag{\push{t}{\PI{\V{x}}{\EnumT{e}} P\:x}}
                               {\\ \PLAM{x}{(\EnumT{e})} \switch{e}{P}{t'}{x}}
                    \end{array}}\;\mbox{t is $[]$ or $[a,b]$}
\\
%% Conversion
\Rule{\Gamma \Vdash \propag{s}
                           {\pull{s'}{S}} \quad 
      \Gamma \Vdash \push{S \equiv T}{\Set}}
     {\Gamma \Vdash \propag{\push{s}{T}}
                           {s'}}
}\]

\caption{Type checking}
\label{fig:type-checking}

\end{figure}

\begin{figure}

\[\stkc{
%% Form
\boxed{\Gamma \Vdash \propag{\CN{exprEx}}{\pull{\CN{term}}{\CN{type}}}}
\\
\\
%% Reversal
%% \Rule{\Gamma \Vdash \propag{\push{T}{\Set}}
%%                            {T'} \quad
%%       \Gamma \Vdash \propag{\push{t}{T'}}
%%                            {t'}}
%%      {\Gamma \Vdash \propag{(\Bhab{t}{T})}
%%                            {\pull{t'}{T'}}} 
%% \\
%% Context
\Axiom{\Gamma ; \xS ; \Delta \Vdash \propag{\x}
                                           {\pull{\x}{S}}}
\qquad
%% Application
\Rule{\stkl{\Gamma \Vdash \propag{f}
                                 {\pull{f'}{\PiTy{S}{T}}} \\
            \Gamma \Vdash \propag{\push{s}{S}}
                                 {s'}}}
     {\Gamma \Vdash \propag{f\: s}{\pull{f'\: s'}{T\: s'}}} 
\\
%% First projection
\Rule{\Gamma \Vdash \propag{p}
                           {\pull{p'}{\SigmaTy{S}{T}}}}
     {\Gamma \Vdash \propag{\fst{p}}
                           {\pull{\fst{p'}}{S}}} \qquad 
%% Second projection
\Rule{\Gamma \Vdash \propag{p}
                           {\pull{p'}{\SigmaTy{S}{T}}}}
     {\Gamma \Vdash \propag{\snd{p}}
                           {\pull{\snd{p'}}{T\:(\fst{p'})}}}
}\]

\caption{Type synthesis}
\label{fig:type-synthesis}

\end{figure}

\subsection{In praise for $\Sigma$}

\begin{structure}
<- What is Sigma in the end?
    <- Sigma generalizes sum over arbitrary ranges
    <- Sigma generalizes product to have dependent second component
<- Impact for data-types?
    <- Simply-typed languages have sums-of-product
    -> Dependently-types languages have Sigmas-of-Sigmas
\end{structure}

\subsection{Desc}

\begin{structure}
<- Without hind!
    <- Simple, first-order version first
    -> See Levitation Section for hind motivation
<- Presented as a signature
    -> ``We promise, this will be realized''
\end{structure}

\[
\stk{
\data \Desc : \Set \where \\
\;\;\begin{array}{@{}l@{\::\:}l@{\quad}l}
    \DUnit          & \Desc \\
    \DSigma         & \PI{\V{S}}{\Set} \PIS{S \To \Desc} \Desc \\
    \DIndx          & \Desc \To \Desc
\end{array}
}
\]

\begin{structure}
<- Interpretation
    -> Object action of a functor
\end{structure}


\[\stk{
\descop{\_\:}{} : \Desc \To \Set \To \Set \\
\begin{array}{@{}ll@{\:=\:\:}ll}
\descop{\DUnit}{& X}        &  \Unit                                       \\
\descop{\DSigma{S}{D}}{& X} &  \SIGMAS{\V{s} : S}{\descop{D~s}{X}}         \\
\descop{\DIndx{D}}{& X}     &  \TIMES{X}{\descop{D}{X}}
\end{array}
}\]

\begin{structure}
<- Examples
    -> Nat
\end{structure}

\[\stk{
\NatD : \Desc \\
\NatD \mapsto \DSigma{(\EnumT [ \NatZero, \NatSuc{} ])}
                     {[ \DUnit \quad (\DIndx{\DUnit}) ]}
}\]

\begin{structure}
    -> List
\end{structure}

\[\stk{
\ListD : \Set \To \Desc \\
\ListD \: X \mapsto \DSigma{(\EnumT [ \ListNil, \ListCons ])}
                           {[ \DUnit \quad (\DSigma{X}{\LAM{\_} \DIndx{\DUnit}}) ]}
}\]

\begin{structure}
    -> Tree
\end{structure}

\[\stk{
\TreeD : \Set \To \Desc \\
\TreeD \: X \mapsto \DSigma{(\EnumT [ \TreeLeaf, \TreeNode ])}
                           {[ \DUnit \quad (\DSigma{X}{\LAM{\_} \DIndx{(\DIndx{\DUnit})}}) ]}
}\]

\begin{structure}
<- Mu
    <- Definition
\end{structure}

\[
\Rule{\Gamma \vdash \Bhab{D}{\Desc}}
     {\Gamma \vdash \Bhab{\Mu{D}}{\Set}} \qquad
\Rule{\Gamma \vdash \Bhab{D}{\Desc} \quad 
      \Gamma \vdash \Bhab{x}{\descop{D}{(\Mu{D})}}}
     {\Gamma \vdash \Bhab{\Con{x}}{\Mu{D}}}
\]

\begin{structure}
    <- Elaboration for data
\end{structure}

\subsection{Induction for $\Mu{D}$}

\[
\begin{array}{lcl}
\F{induction} & : & \PITEL{D}{\Desc}                \\
              &   & \PITEL{P}{\Mu{D} \To \Set}      \\
              &   & \PITEL{m}{\PI{xs}{\descop{D}{(\Mu{D})}} \All{D}{(\Mu{D})}{P}{xs} \To P (\Con{xs})} \\
              &   & \PI{x}{\Mu{D}} P x
\end{array}
\]

This \(\F{induction}\) operator is the natural dependent elimination
principle, but we might also benefit from the traditional \emph{catamorphism}
or `fold operator' which accompanies a (weakly) initial algebra. We should
like to have
\[\stk{
\F{cata} : \PITEL{D}{\Desc}\PI{T}{\Set}
           (\descop{D}{T}\To T)\To \Mu{D}\To T\\
\F{cata}\:D\:T\:f \mapsto
  \F{induction}\:D\:(\LAM{\_}T)\:(\LAM{xs\:ts}f\:?)
}\]
but what should \(?\) be? We have \(xs:\descop{D}{\Mu{D}}\)
and \(ts:\All{D}{(\Mu{D})}{(\LAM{\_}T)}{xs}\), so surely we can construct
an element of \(\descop{D}{T}\) by replacing each recursive component from
\(xs\) with its counterpart from \(ts\).

\[\stk{
\F{replace} : 
\stk{\PITEL{D}{\Desc}\PITEL{X,Y}{\Set}\\
           \PI{xs}{\descop{D}{X}} \All{D}{X}{(\LAM{\_}Y)}{xs} \To
           \descop{D}{Y}}
\\
\F{replace}\:\DUnit\: X\:Y\:\Void\:\Void\mapsto\Void \\
\F{replace}\:(\DSigma{S}{D})\:X\:Y\:\pair{s}{xs}{}\:ys\mapsto
 \pair{s}{\F{replace}\:{D~s}\:X\:Y\:xs\:ys}{}         \\
\F{replace}\:(\DIndx{D})\:X\:Y\:\pair{x}{xs}{}\:\pair{y}{ys}{} \mapsto
    \pair{y}{\F{replace}\:D\:X\:Y\:xs\:ys}{}
}\]

\subsection{Describing enumerations}

\[\stk{
\EnumU : \Set \\
\EnumU \mapsto \Mu{(\List~\UId)}
}\]


\begin{structure}
<- Bye-bye \spi
    /> Keep switch
<- Content stays the same
    /> type naming scheme condenses
\end{structure}


\subsection{Can we describe Desc? Obstacles}

\begin{structure}
<- 'Sigma does higher-order recursion
    -> Introduce hindx
\end{structure}

\[
\stk{
\data \Desc : \Set \where \\
\;\;\begin{array}{@{}l@{\::\:\:}l@{\quad}l}
    \ldots          & \:\:\ldots \\
    \DHindx         & \PI{H}{Set} \Desc \To \Desc
\end{array}
}
\]

\[\stk{
\descop{\_\:}{} : \Desc \To \Set \To \Set \\
\begin{array}{@{}l@{\:=\:\:}ll}
\ldots                        &  \ldots \\
\descop{\DHindx{H}{D}}{X}     &  \TIMES{(H \To X)}{\descop{D}{X}}
\end{array}
}\]

\begin{structure}
    -> Need a special-purpose switchD
\end{structure}


\[\stk{
\DescD : \Desc \\
\begin{array}{@{}ll}
\DescD \mapsto \DSigma{}{} & (\EnumT [ \DUnit, \DSigma{}{}, \DIndx{}, \DHindx{}{} ]) \\
                           & \left[\begin{array}{l}
                                   \DUnit                                \\
                                   \DSigma{\Set}{(\LAM{\V{X}} \DHindx{X}{\DUnit})} \\
                                   \DIndx{\DUnit}                                  \\
                                   \DSigma{\Set}{(\LAM{\_} \DIndx{\DUnit})}
                                   \end{array}
                             \right]
\end{array}
}
\]

\subsection{Bringing the Free Monad in}

\begin{structure}
<- Re-engineer indx-hindx into Pi, x, id
\end{structure}

\[
\stk{
\data \Desc : \Set \where \\
\;\;\begin{array}{@{}l@{\::\:}l@{\quad}l}
    \DId            & \Desc                                   \\
    \DUnit          & \Desc                                   \\
    \DProd{}{}      & \PI{\V{D}, \V{D'}}{\Desc} \Desc         \\
    \DSigma         & \PI{\V{S}}{\Set} \PIS{S \To \Desc} \Desc \\
    \DPi            & \PI{\V{S}}{\Set} \PIS{S \To \Desc} \Desc 
\end{array}
}
\]

\[\stk{
\descop{\_\:}{} : \Desc \To \Set \To \Set \\
\begin{array}{@{}l@{\:=\:\:}ll}
\descop{\DId}{X}          &  X                                           \\
\descop{\DUnit}{X}        &  \Unit                                       \\
\descop{\DProd{D}{D'}}{X} &  \TIMES{\descop{D}{X}}{\descop{D'}{X}}       \\
\descop{\DSigma{S}{D}}{X} &  \SIGMA{\V{s}}{S} \descop{D\: s}{X}                \\
\descop{\DPi{S}{D}}{X}    &  \PI{\V{s}}{S} \descop{D\: s}{X}            
\end{array}
}\]

\begin{structure}
<- Rebuild the examples
Pierre: Really? Can't we just say "look at the transformation below, that's obvious" ?
\end{structure}

A \emph{tagged} description is given by an inhabitant of
\[
 \F{TagDesc} \mapsto \SIGMA{\V{E}}{\EnumU}\spi{\V{E}}{\LAM{\_}\Desc}
\]


\newcommand{\FM}[1]{{#1}^{\F{\(\ast\)}}}
Datatypes specified in the conventional `sum of products' style naturally give rise to tagged descriptions. Of course, every description can be dorced into this style with a singleton choice of tag.

We may then implement the \emph{free monad} construction as a
transformation on \(\F{TagDesc}\).
\[\stk{
\FM{\_} : \F{TagDesc} \To \Set \To \F{TagDesc} \\
\FM{\pair{E}{D}{}}\:X \mapsto
\pair{\ListCons{\:\DVar{}}{E}}{\pair{\DConst{X}}{D}{}}{}
}\]
Of course, we must equip the resulting datatypes with operations delivering a monadic interface. As usual, \(\LAM{\x}\DVar{\x}\) performs the r\^ole of `return', embedding variables into terms. We shall also need a generic \emph{substitution} operator.

\begin{structure}
<- Show the transformation from the previous combinators to the new one
\end{structure}

\[\begin{array}{l@{\:\mapsto\:\:}l}
\DIndx{D}         & \DProd{\DId}{D}                      \\
\DHindx{H}{D}     & \DProd{(\DPi{H}{(\LAM{\_} \DId)})}{D}
\end{array}
\]


\subsection{From Desc to IDesc}

\begin{structure}
<- Labelling the \DId
\end{structure}

%% \[
%% \stk{
%% \data \IDesc{} : \PI{\V{I}}{\Set}{\Set} \where \\
%% \;\;\begin{array}{@{}l@{\::\:}l@{\quad}l}
%%     \DVar           & I \To \IDesc{I}                                   \\
%%     \DUnit          & \IDesc{I}                                         \\
%%     \DProd{}{}      & \PI{\V{D}, \V{D'}}{\IDesc{I}} \IDesc{I}           \\
%%     \DSigma         & \PI{\V{S}}{\Set} \PIS{S \To \IDesc{I}} \IDesc{I}  \\
%%     \DPi            & \PI{\V{S}}{\Set} \PIS{S \To \IDesc{I}} \IDesc{I} 
%% \end{array}
%% }
%% \]


%% \[\stk{
%% \idescop{\_\:}{}{} : \PI{\V{I}}{\Set} \IDesc{I} \To \Set \To \Set          \\
%% \begin{array}{@{}l@{\:=\:\:}ll}
%% \idescop{\DVar{i}}{I}{P}      &  P~i                                         \\
%% \idescop{\DUnit}{I}{P}        &  \Unit                                       \\
%% \idescop{\DProd{D}{D'}}{I}{P} &  \TIMES{\idescop{D}{I}{P}}{\idescop{D'}{I}{P}}       \\
%% \idescop{\DSigma{S}{D}}{I}{P} &  \SIGMA{\V{s}}{S} \idescop{D\: s}{I}{P}                \\
%% \idescop{\DPi{S}{D}}{I}{P}    &  \PI{\V{s}}{S} \idescop{D\: s}{I}{P}            
%% \end{array}
%% }\]

\begin{structure}
<- I -> IDesc I describes an inductive family
\end{structure}

\begin{structure}
<- Replace DUnit by const
\end{structure}


\[
\stk{
\data \IDesc{} : \PI{\V{I}}{\Set} \Set \where \\
\;\;\begin{array}{@{}l@{\::\:}l@{\quad}l}
    \DVar{}         & I \To \IDesc{I}                                   \\
    \DConst{}       & \Set \To \IDesc{I}                                \\
    \DProd{}{}      & \PI{\V{D}, \V{D'}}{\IDesc{I}} \IDesc{I}           \\
    \DSigma         & \PI{\V{S}}{\Set} \PIS{S \To \IDesc{I}} \IDesc{I}  \\
    \DPi            & \PI{\V{S}}{\Set} \PIS{S \To \IDesc{I}} \IDesc{I} 
\end{array}
}
\]


\[\stk{
\idescop{\_\:}{}{} : \PI{\V{I}}{\Set} \IDesc{I} \To \Set \To \Set                  \\
\begin{array}{@{}l@{\:=\:\:}ll}
\idescop{\DVar{i}}{I}{P}      &  P~i                                                 \\
\idescop{\DConst{X}}{I}{P}    &  X                                                   \\
\idescop{\DProd{D}{D'}}{I}{P} &  \TIMES{\idescop{D}{I}{P}}{\idescop{D'}{I}{P}}       \\
\idescop{\DSigma{S}{D}}{I}{P} &  \SIGMA{\V{s}}{S} \idescop{D\: s}{I}{P}                    \\
\idescop{\DPi{S}{D}}{I}{P}    &  \PI{\V{s}}{S} \idescop{D\: s}{I}{P}            
\end{array}
}\]

\begin{structure}
<- Examples
    -> Point out that our old examples fit in 1 -> IDesc 1
    -> Levitate: no big deal
\end{structure}

\[\stk{
\IDescD : \PI{\V{I}}{\Set} \IDesc{\Unit} \\
\begin{array}{ll}
\IDescD~I \mapsto \DSigma{}{} & (\EnumT [ \DVar{},
\DConst{},
                                                                                    \DProd{}{},
                                          \DSigma{}{}, 
                                          \DPi{}{} ]) \\
                              & \left[\begin{array}{l}
                                      \DConst{I}                  \\
                                      \DConst{\Set}               \\
                                      \DProd{\DVar{\Void}}{\DVar{\Void}}  \\
                                      \DSigma{\Set}{(\LAM{S} \DPi{S}{(\LAM{\_} \DVar{\Void})})} \\
                                      \DSigma{\Set}{(\LAM{S} \DPi{S}{(\LAM{\_} \DVar{\Void})})}
                                   \end{array}
                             \right]
\end{array}
}\]

\begin{structure}
    -> untyped lambda terms
        /> What is Fin??
\end{structure}

\[\stk{
\LambdaTD : \Nat \To \IDesc{\Nat} \\
\begin{array}{@{}ll}
\LambdaTD\: n = \DSigma{}{} & (\EnumT [ \LambdaTVar, \LambdaTApp, \LambdaTLam ]) \\
                            & \left[\begin{array}{l}
                                  \DConst{\Fin{n}} \\
                                  \DProd{\DVar{n}}{\DVar{n}} \\
                                  \DVar{(\NatSuc{n})}
                              \end{array}\right]
\end{array}
}\]

\subsection{Constrained constructors, bis}

\begin{structure}
<- Presbyterianism, Episcopalism, Catholicism
<- Brady-optimization: source-to-source
    -> Anglo-catholicism
\end{structure}


%% \[
%% \stk{
%% \data \IDesc{} : \PI{\V{I}}{\Set} \Set \where \\
%% \;\;\begin{array}{@{}l@{\::\:}l@{\quad}l}
%%     \DConst{}       & \Set \To \IDesc{I}                                \\
%%     \DVar{}         & I \To \IDesc{I}                                   \\
%%     \DPrf{}         & \Prop \To \IDesc{I}                               \\
%%     \DProd{}{}      & \PI{\V{D}, \V{D'}}{\IDesc{I}} \IDesc{I}           \\
%%     \DSigma         & \PI{\V{S}}{\Set} \PIS{S \To \IDesc{I}} \IDesc{I}  \\
%%     \DPi            & \PI{\V{S}}{\Set} \PIS{S \To \IDesc{I}} \IDesc{I} 
%% \end{array}
%% }
%% \]


%% \[\stk{
%% \idescop{\_\:}{}{} : \PI{\V{I}}{\Set} \IDesc{I} \To \Set \To \Set                \\
%% \begin{array}{@{}l@{\:=\:\:}ll}
%% \idescop{\DConst{X}}{I}{P}    &  X                                                   \\
%% \idescop{\DVar{i}}{I}{P}      &  P~i                                                 \\
%% \idescop{\DPrf{q}}{I}{P}      &  \prf{q}                                             \\
%% \idescop{\DProd{D}{D'}}{I}{P} &  \TIMES{\idescop{D}{I}{P}}{\idescop{D'}{I}{P}}       \\
%% \idescop{\DSigma{S}{D}}{I}{P} &  \SIGMA{\V{s}}{S} \idescop{D s}{I}{P}                \\
%% \idescop{\DPi{S}{D}}{I}{P}    &  \PI{\V{s}}{S} \idescop{D s}{I}{P}            
%% \end{array}
%% }\]

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Desc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{A simple universe of descriptions}

\begin{structure}
<- a universe of simple inductive types
    -> nil, arg, ind, hind
<- levitation
\end{structure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% IDesc
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Indexing descriptions}


\begin{structure}
<- enumerations
<- indexing
    -> nil, arg, ind, hind
    -> var, Pi, Sigma, :-, x, Sigma_f
<- closure under \box and \diamond
<- Brady optimization as desc transformation
<- ``standard'' descriptions start with Sigma_f
    -> SIDesc : I -> (E : EnumU) -> Branches(E , \ e -> IDesc I )
<- ``standard'' descriptions closed under the free monad constructions
<- IDesc is just such a free monad
\end{structure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Discussion (?)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Discussion}

\begin{structure}
<- universe stratification
    -> how would IDesc play with it?
\end{structure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Conclusion
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion}

\begin{structure}
\end{structure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Appendices
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \appendix
% \section{Appendix Title}

% This is the text of the appendix, if you need one.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Acknowledgments
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \acks

% Acknowledgments, if needed.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Bibliography
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\bibliography{paper}
\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.
%\begin{thebibliography}{}
%\softraggedright
%\end{thebibliography}

\end{document}
