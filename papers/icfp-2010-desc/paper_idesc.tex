\section{Indexing descriptions}
\label{sec:indexing-desc}

\begin{wstructure}
!!! Need Help !!!
<- Motivation
    <- Desc: expressivity of simply-typed data-types: inductive types
        <- Values do not influence types
    /> Example: Vectors
        <- Cannot be defined by just induction
            <- Vectors of all size need to be defined at the *same* time
            -> Defined as a *family* of types
                -> Index
        -> I -> IDesc I: Inductive family
    ???
\end{wstructure}

\note{ Need care: motivating motivation of indexing. }

So far, we have explored the well-known realm of inductive types. We
have built upon the experience gained in using simply-typed languages,
such as Haskell or OCaml. In our dependent setting, we provided these
data-types by the mean of $\Desc$, a universe of descriptions. 

While inductive types are the alpha and omega of simply-typed
languages, evolving in a dependent setting fosters new
opportunities. The typical example is bounded lists, also known as
vectors. A vector is a list decorated by its length. Having this
information prevents hazardous operations, such as taking the head of
an empty vector: the head function only takes vectors of length
$\NatSuc{n}$, as enforced by its type. This is made possible by the
very specificity of dependently-typed systems: terms -- the length --
are allowed to influence types -- the vector type.

However, this new class of objects cannot be defined by mere
induction. In the case of vectors, for instance, we have to define the
whole \emph{family} of vector in one go: vectors of all size needs to
be defined at the same time. Where simply-typed languages have
inductive types, we adopt inductive family of types as our basic
grammar of data-types. To this end, we rely on \emph{indexing}. We are
going to transform the $\Desc$ universe into $\IDesc$, the universe of
indexed descriptions. We express inductive families by the $I \To
\IDesc{I}$ type.

\subsection{Desc, atomically}

\begin{wstructure}
<- Adding hindx have introduced some duplication
    <- indx == hindx 1
    -> We can factor out commonalities 
        /> Obtain an equivalent presentation
        /> Still embeddable (refer to the Agda model)
\end{wstructure}

Before moving on indexed descriptions, we have to carry out some
maintenance work on descriptions. We presented $\Desc$ as the grammar
of inductive types. Hence, the codes closely follow this grammar. In
the following, we adopt an alternative presentation. With $\DSigma$,
we are actually \emph{quoting} a standard type-former, namely

$$\Bhab{\Sigma}{\PI{\V{S}}{\Set} (S \To \Set) \To \Set}$$

In the alternative presentation, we go further and present all our
codes as quotations of standard type-formers. This presentation is
shown in Figure~\ref{fig:type-former-desc}.

This reorganisation is strictly equivalent to the previous one
(Fig.~\ref{fig:hindx_desc}). Just as the previous version, it is also
self-descriptive. We refer the reader to the companion technical
report for details. In this finer-grained presentation, we can define
$\DIndx$ and $\DHindx$ as follow:

\[\begin{array}{l@{\:\mapsto\:\:}l}
\DIndx{D}         & \DProd{\DId}{D}                      \\
\DHindx{H}{D}     & \DProd{(\DPi{H}{(\LAM{\_} \DId)})}{D}
\end{array}
\]

Consequently, the examples previously developed can be
straightforwardly translated into this new presentation. \note{We
  might want to re-do the Nat example here, as we encode once again in
  $\IDesc$} In the following, we adopt this last version as our de
facto universe of inductive types. In particular, we are going to
evolve this presentation into an indexed one.

\note{Shall we talk about the Type Theory being Desc Zero? or such story?}

\begin{figure*}

\[
\begin{array}{ll}
\stk{
\data \Desc : \Set \where \\
\;\;\begin{array}{@{}l@{\::\:}l@{\quad}l}
    \DId            & \Desc                                   \\
    \DUnit          & \Desc                                   \\
    \DProd{}{}      & \PI{\V{D}, \V{D'}}{\Desc} \Desc         \\
    \DSigma         & \PI{\V{S}}{\Set} \PIS{S \To \Desc} \Desc \\
    \DPi            & \PI{\V{S}}{\Set} \PIS{S \To \Desc} \Desc 
\end{array}
}
&
\stk{
\descop{\_\:}{} : \Desc \To \Set \To \Set \\
\begin{array}{@{}l@{\:=\:\:}ll}
\descop{\DId}{X}          &  X                                           \\
\descop{\DUnit}{X}        &  \Unit                                       \\
\descop{\DProd{D}{D'}}{X} &  \TIMES{\descop{D}{X}}{\descop{D'}{X}}       \\
\descop{\DSigma{S}{D}}{X} &  \SIGMA{\V{s}}{S} \descop{D\: s}{X}                \\
\descop{\DPi{S}{D}}{X}    &  \PI{\V{s}}{S} \descop{D\: s}{X}            
\end{array}
}
\end{array}
\]

\caption{Universe of descriptions based on Type-formers}
\label{fig:type-former-desc}

\end{figure*}



\subsection{From Desc to IDesc}

\begin{wstructure}
<- Labelling Id
    <- We had: data Desc : Set -> Set
    -> We want: data IDesc : (I -> Set) -> Set
        <- Indexed functor (?)
        -> It is sufficient to label Id
            <- Where the functor is built
\end{wstructure}

In the previous section, we have presented the $\Desc$ universe as the
grammar of functors in the category $\Set$. We have seen how to encode
inductive types in this setting. To encode an inductive family indexed
by $\Bhab{\V{I}}{\Set}$, we rely on functors in the category
$\Set^I$. We call these \emph{indexed functors}. In the following, we
implement $I \To \IDesc{I}$ as a grammar for indexed functors:

\[\stk{
\data \IDesc{} (\Bhab{\V{I}}{\Set}) : \Set \where \\
\;\;\ldots \\
\\
\idescop{\_\:}{}{} : \PI{\V{I}}{\Set} \IDesc{I} \To (\V{I} \To \Set) \To \Set    \\
\ldots
}\]

This generalisation can be achieved by a minor evolution of $\Desc$
(Fig.~\ref{fig:type-former-desc}). Indeed, the functorial nature of $\Desc$
is entirely captured by the $\DId$ code. We get an indexed functor
by turning $\DId$ into an index-dependent $\DVar$ code:

\[\stk{
\data \IDesc{} (\Bhab{\V{I}}{\Set}) : \Set \where \\
\;\;\begin{array}{@{}l@{\::\:}l@{\quad}l}
    \DVar{}         & I \To \IDesc{I}                                   \\
    \ldots          & \ldots
\end{array} \\
\\
\idescop{\_\:}{}{} : \PI{\V{I}}{\Set} \IDesc{I} \To (\V{I} \To \Set) \To \Set        \\
\begin{array}{@{}l@{\:=\:\:}ll}
\idescop{\DVar{i}}{I}{P}      &  P~i                                                 \\
\ldots                        &  \ldots
\end{array}
}\]

\begin{wstructure}
<- Also replacing '1 by 'const  [figure]
    <- For convenience
        <- 'const X equivalent to 'sigma X (\_ -> '1)
        /> Easier to abstract
            <- Extensionally same
            /> 'const more useful in practice
\end{wstructure}

The resulting code of $\IDesc$ is presented in
Figure~\ref{fig:idesc}. The reader will notice that we have also
replaced $\DUnit$ by a more general $\DConst$ code. Whereas $\DUnit$
was interpreted as the unit set, $\DConst{X}$ is interpreted as $X$,
for any $\Bhab{X}{\Set}$. Extensionally, $\DConst{X}$ and
$\DSigma{X}{\DUnit}$ are equivalent. However, $\DConst$ is more
succinct. More importantly, $\DConst$ is \emph{first-order}, unlike
its equivalent encoding. From a definitional perspective, we are
giving more opportunities to the type-system, hence reducing the
burden on the programmer.

\begin{figure*}

\[
\begin{array}{ll}
\stk{
\data \IDesc{} (\Bhab{\V{I}}{\Set}) : \Set \where \\
\;\;\begin{array}{@{}l@{\::\:}l@{\quad}l}
    \DVar{}         & I \To \IDesc{I}                                   \\
    \DConst{}       & \Set \To \IDesc{I}                                \\
    \DProd{}{}      & \PI{\V{D}, \V{D'}}{\IDesc{I}} \IDesc{I}           \\
    \DSigma         & \PI{\V{S}}{\Set} \PIS{S \To \IDesc{I}} \IDesc{I}  \\
    \DPi            & \PI{\V{S}}{\Set} \PIS{S \To \IDesc{I}} \IDesc{I} 
\end{array}
}
&
\stk{
\idescop{\_\:}{}{} : \PI{\V{I}}{\Set} \IDesc{I} \To (\V{I} \To \Set) \To \Set                  \\
\begin{array}{@{}l@{\:=\:\:}ll}
\idescop{\DVar{i}}{I}{P}      &  P~i                                                 \\
\idescop{\DConst{X}}{I}{P}    &  X                                                   \\
\idescop{\DProd{D}{D'}}{I}{P} &  \TIMES{\idescop{D}{I}{P}}{\idescop{D'}{I}{P}}       \\
\idescop{\DSigma{S}{D}}{I}{P} &  \SIGMA{\V{s}}{S} \idescop{D\: s}{I}{P}                    \\
\idescop{\DPi{S}{D}}{I}{P}    &  \PI{\V{s}}{S} \idescop{D\: s}{I}{P}            
\end{array}
}
\end{array}
\]

\caption{Universe of indexed description}
\label{fig:idesc}

\end{figure*}

\subsection{Tagged indexed descriptions}

\begin{wstructure}
<- Tagged constructor choice
    <- Index available when defining the data-type
        -> Can influence the choice of constructors
        -> Dependently-typed data-types
            <- term (index) influence types
    -> Two parts
        <- Always on the menu
            <- E : EnumU 
            <- ED : E -> IDesc I
        <- Index-dependent
            <- F : I -> EnumU 
            <- FD : (i : I) -> spi (F i) (\_ -> IDesc I)
        -> taggedIDesc I == Sigma E ED x Sigma F FD
        -> toIDesc : (I : Set) -> taggedIDesc I -> (I -> IDesc I)
\end{wstructure}

In Section~\ref{sec:desc-examples}, we have defined a \emph{tagged}
form for descriptions. This format follows the usual presentation of
inductive types as sum-of-product. With indexed description, this
definition can be generalized. Indeed, when defining an indexed
data-type, we have access to this index. Therefore, we can use this
index to influence the choice of constructors. This captures the
essence of dependent data-types: a term -- the index -- has the
ability to influence the data-type.

For convenience, we divide a tagged indexed description in two parts:
first, the constructors that do not depend on the index; then, the
constructors that do. The non-dependent part mirrors the definition
for non-indexed descriptions: we are provided a finite choice of
constructors. The index-depend part simply indexes the choice of
constructors by $I$. Hence, by inspecting the index, it is possible to
enable or disable the constructors. 

\[\stk{
 \TagIDesc{I}  \mapsto \TIMES{\ATagIDesc{I}}{\ITagIDesc{I}}
 \ATagIDesc{I} \mapsto \SIGMA{\V{E}}{\EnumU} (\PI{\V{i}}{I} \spi{\V{E}}{(\LAM{\_} \IDesc{I})}) \\
 \ITagIDesc{I} \mapsto \SIGMA{\V{F}}{I \To \EnumU} (\PI{\V{i}}{I} \spi{(F\: i)}{(\LAM{\_} \IDesc{I})})  \\
}\]

In the case of vectors, for instance, for the index $\NatZero$, we
would only propose the constructor $\ListNil$. Similarly, for
$\NatSuc{n}$, we only propose the constructor $\ListCons{}{}$. We will
see more instances of this pattern in the following.



\note{Should we say something about IMu, fixed-points, and their
  elimination before moving on? If so, where should we put it?}


\subsubsection{Examples}
\label{sec:idesc-examples}

\paragraph{Natural numbers:}

\begin{wstructure}
<- Nat
    -> [equation]
    <- Non-indexed types lives in IDesc 1
        -> This applies to all previous examples
\end{wstructure}

In order to gain some intuition with $\IDesc$, let us re-implement the
signature functor of natural numbers. We refer the reader to
Section~\ref{sec:desc-examples} for its incarnation in the universe of
descriptions. The code is the following:

\[\stk{
\NatD : \IDesc{\Unit} \\
\NatD \mapsto \DSigma{(\EnumT [ \NatZero, \NatSuc{} ])}
                     {[ \DConst{\Unit} \quad (\DVar{\Void}) ]}
}\]

Because $\Nat$ is just an inductive type, we make no use of the index:
it is the trivial inhabitant of $\Unit$. Therefore, the recursive
argument is materialised by $\DVar{\Void}$, where we were using $\DId$
in the $\Desc$ presentation. This transformation applies to all
inductive types: we have not lost in expressive power during the
transition.

\paragraph{Indexed descriptions:}

\begin{wstructure}
<- Levitation [figure]
    <- Following Desc encoding
        /> Note: simple data-type
            -> Live in IDesc 1
    -> Behind the scene, relies on the special purpose switchD
\end{wstructure}

A mandatory exercise consists in describing $\IDesc$ in itself. With
the experience gained in Section~\ref{sec:desc-levitate}, this
levitation does not pose any issue:

\[\stk{
\IDescD : \PI{\V{I}}{\Set} \IDesc{\Unit} \\
\begin{array}{@{}ll}
\IDescD~I \mapsto \DSigma{}{} & (\EnumT [ \DVar{},
                                          \DConst{},
                                          \DProd{}{},
                                          \DSigma{}{}, 
                                          \DPi{}{} ]) \\
                              & \left[\begin{array}{l}
                                      \DConst{I}                  \\
                                      \DConst{\Set}               \\
                                      \DProd{\DVar{\Void}}{\DVar{\Void}}  \\
                                      \DSigma{\Set}{(\LAM{S} \DPi{S}{(\LAM{\_} \DVar{\Void})})} \\
                                      \DSigma{\Set}{(\LAM{S} \DPi{S}{(\LAM{\_} \DVar{\Void})})}
                                   \end{array}
                             \right]
\end{array}
}\]

Note that this description also lives in $\IDesc{\Unit}$. Indeed,
$\IDesc$ is merely an inductive type. As for the $\Desc$ levitation,
the finite function space $[ \ldots ]$ elaborates into a special
purpose $\F{switchID}$ operator. 

\paragraph{Typed expressions:}

\begin{wstructure}
<- Hutton's razor
    <- Types
        <- 'Nat
        <- 'Bool
    <- Term [figure]
        <- val : Val 'a -> 'a  for Val : Ty -> Set, mapping to Nat and Bool
        <- cond : 'Bool -> a -> a -> a
        <- plus : 'Nat -> 'Nat -> 'Nat
        <- le : 'Nat -> 'Nat -> 'Bool
\end{wstructure}

%% Types
\newcommand{\Ty}{\C{Ty}}
\newcommand{\Ebool}{\etag{\CN{bool}}}
\newcommand{\Enat}{\etag{\CN{nat}}}
\newcommand{\Epolym}{\etag{\alpha}}

%% Constructors
\newcommand{\Eval}[1]{\etag{\CN{val}}~#1}
\newcommand{\Econd}[3]{\etag{\CN{cond}}~#1~#2~#3}
\newcommand{\Eplus}[2]{\etag{\CN{plus}}~#1~#2}
\newcommand{\Ele}[2]{\etag{\CN{le}}~#1~#2}

%% Index mapper (terminology?)
\newcommand{\Val}[1]{\D{Val}~#1}
\newcommand{\Var}[2]{\D{Var}_{#1}~#2}

%% Hutton expressions
\newcommand{\HExprD}{\C{ExprD}}
\newcommand{\HExprAD}{\C{ExprAlwaysD}}
\newcommand{\HExprID}{\C{ExprIndexedD}}
\newcommand{\HExprVarD}{\C{ExprD}_{\C{Var}}}
\newcommand{\HExprFreeD}{\C{ExprD}_{\C{Free}}}
\newcommand{\HExprAFreeD}{\C{ExprAlwaysD}_{\C{Free}}}

So far, the examples we have seen lives in $\IDesc{\Unit}$, hence are
not using any indexing. We are going to define a syntax for a small
typed language. We consider two types, natural numbers and booleans:

\[
\Ty \mapsto \EnumT{[\Enat \quad \Ebool]}
\]

An expression of this language is either a value, a conditional
expression, addition of numbers, or comparison of numbers. Informally,
their type is the following:

\[
\begin{array}{l@{\::\:\:}l}
\Econd{}{}{}     & \Ebool \To \Epolym \To \Epolym \To \Epolym  \\ 
\Eplus{}{}       & \Enat \To \Enat \To \Enat                   \\
\Ele{}{}         & \Enat \To \Enat \To \Ebool                  \\
\Eval{}          & \Val{\Epolym} \To \Epolym
\end{array}
\]

The notation $\Epolym$ represents a form of ``polymorphism'', meaning
that $\alpha$ can be any type. \note{Polymorph? Will any ghost try to
  haunt me with that?  A ghost under a mixed prefix?
  Aaaaaaaaaaargh\ldots}

The function $\Val{}$, used in the definition of $\Eval{}$, simply
maps $\Epolym$ to the corresponding type in the host language. Hence,
the argument of $\Eval{}$ are ensured to be of the expected type. We
assume $\Nat$ and $\Bool$ represent natural numbers and booleans in
the host language. Further, we also assume the existence of an
addition and comparison operator in $\Nat$, respectively named
$\F{plusHost}$ and $\F{leHost}$. We define $\Val{}$ as follow:

\[\stk{
\Val{} : \Ty \To \Set \\
\begin{array}{@{}l@{\:=\:\:}l}
\Val{\Enat}   & \Nat \\
\Val{\Ebool}  & \Bool
\end{array}
}\]

In our universe of descriptions, this data-type is represented by a
tagged indexed description. We use the index to carry the type: the
resulting description is indexed by $\Ty$. We observe that some
constructors are ``polymorph'', namely $\Econd{}{}{}$ and $\Eval{}$. On the
other hand, the $\Eplus$ and $\Ele$ constructors are
index-dependent. $\Eplus$ is defined if and only if the result type --
the index -- is $\Enat$, whereas $\Ele$ is defined if and only if the
index is $\Ebool$. The actual code precisely follows this intuition,
as shown in Figure~\ref{fig:hexpr-full}. For brevity, we use an
informal $\case{\ldots}{\ldots}$ notation, simulating a definition by
pattern-matching. Formally, this corresponds to a call to the
$\switch{}{}{}{}$ eliminator.

\begin{figure*}

\[\stkc{
\stk{
\HExprD : \TagIDesc{\Ty} \\
\HExprD \mapsto ( \HExprAD , \HExprID ) \\
} \\
\\
\begin{array}{ll}
\stk{
\HExprAD : \ATagIDesc{\Ty} \\
\HExprAD \mapsto \left[
                 \begin{array}{l}
                   \EnumT{[\Eval{}  \Econd{}{}{}]} \red{,} \\
                   \LAM{ty}
                   \left[ %%! Should be read
                   \begin{array}{l}
                   \DConst{(\Val{ty})} \\
                   \DProd{\DVar{\Ebool}}{\DProd{\DVar{ty}}{\DVar{ty}}}
                   \end{array}
                   \right]
                 \end{array}
                 \right] %%! Should be \red
\\
\\
} &
\stk{
\HExprID : \ITagIDesc{\Ty} \\
\HExprID \mapsto \left[
                 \begin{array}{l}
                   \LAM{ty} \case{ty}{\Enat \To \EnumT{[\Eplus{}{}]} \\ \Ebool \To \EnumT{[\Ele{}{}]}} \red{,} \\
                   \LAM{ty}
                   \case{ty}{
                     \Enat \To \DProd{\DVar{nat}}{\DVar{nat}} \\
                     \Ebool \To \DProd{\DVar{nat}}{\DVar{nat}}
                   }
                   \end{array}
                   \right]
}
\end{array}
}\]

\caption{Syntax of typed expressions}
\label{fig:hexpr-full}

\end{figure*}

\note{the big square brackets should be red}

\begin{wstructure}
    -> evaluation: IMu TermD -> Val
        -> it is a catamorphism
            <- Look closer at the type
        -> implementation [code]
            <- Just define one reduction step
            -> cata does the rest
                /> cata is for free!
\end{wstructure}

\newcommand{\evalH}{\F{eval}_{\green{\Downarrow}}}
\newcommand{\evalOne}{\F{eval}_{\green{\downarrow}}}

Having implemented the syntax, we would like to describe its
semantics. To do so, we implement an evaluator. The type of the
evaluator is:

\[
\evalH : \PI{\V{ty}}{\Ty} 
         \IMu{\Ty}{\toIDesc{\HExprD}}{ty} \To
         \Val{ty}
\]

The type of $\F{eval}$ is strikingly similar to a
catamorphism. Indeed, implementing a single step of evaluation -- the
algebra -- is sufficient, as $\F{cataI}$ \note{We have not defined
  \F{cataI}!} gives, for free, the full evaluator. The implementation
is as follow:


\[\stk{
\evalOne : \PI{\V{ty}}{\Ty} \idescop{\toIDesc{\HExprD}}{\Ty}{ty} \To {\Val{ty}} \\
\begin{array}{@{}l@{\:=\:\:}l}
\evalOne\: \_\: \pair{\Eval{}}{x}{}                                         & x \\
\evalOne\: \_\: \pair{\Econd{}{}{}}{\pair{\BoolTrue}{\pair{x}{\_}{}}{}}{}   & x \\
\evalOne\: \_\: \pair{\Econd{}{}{}}{\pair{\BoolFalse}{\pair{\_}{y}{}}{}}{}  & x \\
\evalOne\: \Enat\: \pair{\Eplus{}{}}{\pair{x}{y}{}}{}                       & \F{plusHost}\: x y \\
\evalOne\: \Ebool\: \pair{\Ele{}{}}{\pair{x}{y}{}}{}                        & \F{leHost}\: x y 
\end{array} \\
\\
\evalH : \PI{\V{ty}}{\Ty} 
           \IMu{\Ty}{\toIDesc{\HExprD}}{ty} \To
           \Val{ty} \\
\evalH\: ty\: term = \F{cataI}\: \Ty\: 
                                 \toIDesc{\HExprD}\: 
                                 \Val{}\: 
                                 \evalOne\: 
                                 ty\: 
                                 term
}\]


\begin{wstructure}
    /> Closed term
        <- only constants and operations on them
        -> Extend Val with Var : Ty -> Set, mapping to EnumU
            -> Open term
            -> Language of well-typed terms
                <- By construction
\end{wstructure}

Hence, we have defined the syntax of a typed language of arithmetic
and boolean operations. We have given its semantics through an
evaluation function. Provided a one step semantic of the language, the
big step evaluation is granted without effort thanks to the generic
catamorphism. 

However, so far, we are only able to define and manipulate
\emph{closed} terms. By abstracting over $\Val{}$, it is possible to
build and manipulate \emph{open} terms, that is terms with symbolic
variables. On the model of $\Val{}$, we define $\Var{}{}$:

\[\stk{
\Var{}{} : \EnumU \To \Ty \To \Set \\
\Var{dom}{\_} = \EnumT{dom}
}\]

Whereas $\Val{}$ was mapping the type to the corresponding host type,
$\Var{}{}$ maps types to a finite set. The finite set -- the context
-- contains closed terms. A variable is therefore a $\Eval{}$ that
contains a pointer to a particular element of the finite set -- an
element of $\EnumT{dom}$. The extra argument to $\Var{}{}$ is the
domain of this context.

Consequently, replacing $\Val{ty}$ by $(\SUM{\Val{ty}}{\Var{dom}{ty}})$ in
Figure~\ref{fig:hexpr-full} turns the language of closed term into a
language of opened terms with constants. \note{Is it polite and
  comprehensible to ask that?} This defines a new indexed description,
called $\HExprVarD$.

\begin{wstructure}
        <- evaluator, with a context
            -> First, close variables
                -> Perform assignment
                <- subst [code]
\end{wstructure}

\newcommand{\discharge}{\F{discharge}}

Again, we would like to give a semantics to this extended language. We
proceed in two steps: first, we replace the variables by their value
in the context; then, we evaluate the resulting closed term. Thanks to
$\evalH$, we are already able to solve the second problem. Let us
focus on discharging variables from the context. Again, we can
subdivide this problem: first, we need the ability to discharge a
single variable from the context; then, we apply this $\discharge$
function on every variables in the term.

The $\discharge$ function is relative to the required type, the domain
of the context, and a context containing values of the corresponding
type. Its action is to map variables to their value in context, and
directly return constant values. This corresponds to the following
function:

\[\stk{
\begin{array}{@{}ll}
\discharge : & \PITEL{\V{ty}}{\Ty}
               \PITEL{\V{dom}}{\EnumU} \\
             & \PI{\V{\gamma}}{\spi{dom}{(\LAM{\_} \IMu{\Ty}{\toIDesc{\HExprVarD}}{ty})}} \\
             & (\SUM{\Val{ty}}{\Var{dom}{ty}}) \To
               \IMu{\Ty}{\toIDesc{\HExprD}}{ty} 
\end{array} \\
\begin{array}{@{}l@{\:\mapsto\:\:}l}
\discharge\: ty\: dom\: \gamma\: (\SumLeft x)  & \Con{\pair{\Eval{}}{x}{}} \\
\discharge\: ty\: dom\: \gamma\: (\SumRight v) & \switch{dom}{(\LAM{\_} \IMu{\Ty}{\toIDesc{\HExprVarD}}{ty})}{\gamma}{v}
\end{array}
}\]

\begin{wstructure}
            /> Then, perform subst everywhere in the term
                -> Show type [code]
                /> This is a bind!?
                -> There is some more structure 
                    -> We should try to get it
\end{wstructure}

Having implemented the local $\discharge$ operation, we are left with
applying it over all variables of the term. The type of this operation
is the following:

\newcommand{\substH}{\F{substExpr}}

\[
\begin{array}{@{}ll}
\substH  : & \PITEL{\V{ty}}{\Ty}
            \PITEL{\V{dom}}{\EnumU} 
            \PITEL{\V{\gamma}}{\spi{dom}{(\LAM{\_} \IMu{\Ty}{\toIDesc{\HExprVarD}}{ty})}} \\
          &  \PI{\V{\sigma}}{\PI{\V{ty}}{\Ty} (\Val{ty} + \Var{dom}{ty}) \To
                             \IMu{\Ty}{(\toIDesc{\HExprD})}{ty}} \\
          & \IMu{\Ty}{\toIDesc{\HExprVarD}}{\V{ty}} \To
            \IMu{\Ty}{\toIDesc{\HExprD}}{\V{ty}}
\end{array}
\]

Abstracting away the book-keeping introduced by the context, this
definition looks familiar. Indeed, it is extremely similar to a
monadic ``bind''. This is not surprising as we are defining a
first-order syntax with variables: our data-type enjoys more structure
than what we are given. In particular, this is reminiscent to a free
monad, where $\Eval{}$ is the ``return'' introducing
variables. Instead of implementing $\substH$ in this special case, we
shall implement it in a generic setting, and express our example in
that setting. However, before entering the realm of generic
structures, let us further explore the universe of indexed
descriptions.

\subsection{Constrained constructors}

\begin{wstructure}
!!! Need Help !!!
<- Assuming a suitable notion of definitional equality for I
    ???
\end{wstructure}

In the following, we ask $I$ to come equipped with a notion of
definitional equality. Hence, we can legibly equates elements of $I$.

\note{ I will need some tutorial on this ad-hoc notion of definitional
  equality. Or what Conor's meant with that. }

\begin{wstructure}
<- Fin [figure]
    <- Presentation with equality constraints
    <- Example of constrained constructor
        -> Constraints are translated into equalities
    ???
\end{wstructure}
 
Another common dependent data-type is $\Fin$, the finite sets of
numbers. $\Fin$ is a typical example of an inductive family using
\emph{constrained constructors}. The constructors $\FinZero$ and
$\FinSuc$ are only defined for an index distinct from $\NatZero$:

\[
\Rule{\Bhab{n}{\Nat}}
     {\Bhab{\FinZero}{\Fin{(\NatSuc{n})}}}
\qquad
\Rule{\Bhab{n}{\Nat} \quad 
      \Bhab{i}{\Fin{n}}}
     {\Bhab{\FinSuc{}}{\Fin{(\NatSuc{n})}}}
\]

One way to code constrained data-type is to appeal to equality. The
constraints are therefore captured by equations in the data-type. In
this case, we obtain the following definition:

\[\stk{
\FinD : \Nat \To \IDesc{\Nat} \\
\begin{array}{@{}ll}
\FinD\: n = \DSigma{}{} & (\EnumT [ \FinZero , \FinSuc{} ]) \\
                        & \left[
                          \begin{array}{l}
                            \DSigma{\Nat}{\LAM{m} \DConst{(n \PropEq \NatSuc{m})}} \\
                            \DSigma{\Nat}{\LAM{m} \DProd{\DVar{m}}{\DConst{(n \PropEq \NatSuc{m})}}}
                          \end{array}
                          \right]
\end{array}
}\]

Intuitively, the constraint is captured as follow. First, we store an
element $m$ of $\Nat$, thanks to a $\DSigma$. However, the constraint
stipulates that $m$ cannot be \emph{any} natural numbers: it must be
``the index minus one''. This translates into the constraint $n
\PropEq \NatSuc{m}$. 

\note{ Anything else? }

\begin{wstructure}
<- Vectors
    Do we treat them in the end? 
    What can we say here we haven't with Fin?
\end{wstructure}

\note{ I suspect we don't implement vectors, space-wise }

\begin{wstructure}
<- GADT-style data-type definition
    <- We directly support it
        <- Constraints turned into equalities
            <- Fin example
    <- Again, smooth transition from "today" data-types to advanced ones
        <- Same grammar
        /> More power
    /> Equations in data-types are not a blessing
        <- Complexify induction principle
        <- Lose match between data-type definition and the elimination form
\end{wstructure}

The $\Fin$ example is also a well-known example of Generalised
Abstract Data-Type (GADT) in Haskell. It comes as no surprise that our
universe of indexed description supports this restricted class of
dependent data-types. As we have shown with $\Fin$, constrained
constructors are straightforwardly translated into equality
constraints.

While we support the same grammar, indexed descriptions embraces a
much wider class of data-types. Indeed, we pose no constraint apart
from strict positivity. This suggests that, based on the familiar
grammar of GADTs, we can simply lift off the restrictions and
translates the user's input to a code in our universe of indexed
description. 

However, one could, quite rightfully, be worried by the introduction
of equations in the picture. In the context of programming, these
equations will come back and haunt us, begging for proofs. Hence,
whereas the user typed a constructor-constrained data-type, the
elimination form will involve equations and their proofs. This
introduces a loophole in our abstraction we should try to address.

\note{Is that convincing? Worth saying? Anything else?}

\begin{wstructure}
!!! Need Help !!!
<- Brady optimisation: forcing
    <- Source to source translation
    <- Able to remove some constraints
    -> Example: Fin [figure]
    ??? More technical detail needed
\end{wstructure}

To get a clue of a solution, let us look back at $\Fin$. We note that
the equation is introduced because we are \emph{storing} the index of
the inductive family, through $m$. Hence the constraint. However,
\emph{inductive families need not store their
  indices}~\cite{brady:index-inductive-families}\note{ I'm not
  familiar with this, I need to get into the paper. }. Applying the
\emph{forcing} optimisation to our definition of $\Fin$ gives the
following, equivalent definition:

\[\stk{
\FinD : \Nat \To \IDesc{\Nat} \\
\begin{array}{@{}llll}
\FinD\: 0            & = & \multicolumn{2}{l}{\DSigma{\Void}{\Void} } \\
\FinD\: (\NatSuc{n}) & = & \DSigma{}{} & (\EnumT [ \FinZero , \FinSuc{} ]) \\
                     &   &             & \left[
                                         \begin{array}{l}
                                         \DConst{\Unit} \\
                                         \DVar{n}
                                         \end{array}
                                         \right]
\end{array}
}\]

Equations have simply disappeared! We should precise that forcing a
description is not guaranteed to remove all constraints. It is subject
of future work to see if constraints can be entirely eradicated, or
presented more conveniently to the user. Finally, it is worth
mentioning that the forcing optimisation is a \emph{source-to-source}
transformation of the description.

\subsection{Free IMonad}

\begin{wstructure}
<- Variation on a theme: free imonad construction
    <- Recall existence of generic free monad construction
    -> Present its generalisation to IDesc [equation]
        <- \I -> IDesc I as describing an indexed endofunctor
        <- Free monad construction
    -> Still a suitable, generic notion of substitution
        <- show type signature
        <- show implementation?? (space! space!)
\end{wstructure}

In this section, we develop more structure for our indexed
data-types. In Section~\ref{sec:desc-free-monad}, we have constructed
a free monad operation on simple descriptions. Building on this
experience, we are going to present its equivalent in the indexed
world. The processus is the same. Namely, given an indexed functor, we
derive the indexed functor coding its free monad:

\[\stk{
\begin{array}{ll}
\FreeIMonad{\_}{} : & \PITEL{\V{I}}{\Set}
                      \PITEL{\V{X}}{\V{I} \To \Set} \\
                    & \PITEL{\V{R}}{\V{I} \To \TagIDesc{I}} \To
                      (\V{I} \To \TagIDesc{I})
\end{array} \\
\FreeIMonad{R}{I}{X} \mapsto
    \LAM{i}
    \pair{\ListCons{\DVar{}}{(\fst{(R\: i)})}}
         {\pair{(\DConst{X\: i})}
               {(\snd{(R\: i)})}{}}{}
}\]

Just as in the universe of descriptions, this construction comes with
an obvious ``return'' and a substitution operation, the ``bind''. Its
type signature is the following:

\newcommand{\substI}{\F{substI}}

\[
\begin{array}{@{}ll}
\substI : & \PITEL{\V{I}}{\Set}
            \PITEL{\V{X}, \V{Y}}{\V{I} \To \Set}
            \PITEL{\V{R}}{\V{I} \To \TagIDesc{\V{I}}} \\
          & \PITEL{\V{\sigma}}{\PI{\V{i}}{\V{I}} \V{X}\:\V{i} \To 
                               \IMu{I}{(\FreeIMonad{\V{R}}{\V{I}}{\V{Y}})}{\V{i}}} \\
          & \PITEL{\V{i}}{\V{I}}
            \PITEL{\V{D}}{\IMu{I}{(\FreeIMonad{\V{R}}{\V{I}}{\V{X}})}{\V{i}}} \To
            \IMu{I}{(\FreeIMonad{\V{R}}{\V{I}}{\V{Y}})}{\V{i}}
\end{array}
\]


\subsubsection{Examples}

\paragraph{Typed expressions:}

\begin{wstructure}
<- Hutton's razor is a free monad
    <- substI was our candidate bind
        -> Massage the definition of expr to get it for free
    <- Finding the functor
        <- 'val is the return
        <- The other components are the action
        -> Updated tagged description [figure]
    -> Compute the free monad Hutton * X
        -> With X = Val: We get back our closed terms
        -> With X = Val + Var vars: We get back our open terms
\end{wstructure}

In Section~\ref{sec:idesc-examples}, we had the intuition that our
datatypes $\HExprD$ and $\HExprVarD$ enjoy a monadic structure. We had
identified the variable substitution operation as the ``bind'' of a
free monad. The definition of $\substI$ above confirm our intuition:
using $\substI$, we should easily obtain $\substH$. To do so, we first
have to massage the definition of our data-type, to exhibit its
monadic structure.

As previously mentioned, we identify $\Eval{}$ as the ``return'' of
the free monad, while the other components are the action of the
monad. As a result, the definition is similar to $\HExprD$ presented
in Figure~\ref{fig:hexpr-full}, at the exception of $\HExprAD$ that is
replaced by $\HExprAFreeD$:

\[\stk{
\HExprAFreeD : \ATagIDesc{\Ty} \\
\HExprAFreeD \mapsto \left[
                 \begin{array}{l}
                   \EnumT{[\Econd{}{}{}]} \red{,} \\
                   \LAM{ty}
                   \left[ %%! Should be red
                   \begin{array}{l}
                   \DProd{\DVar{\Ebool}}{\DProd{\DVar{ty}}{\DVar{ty}}}
                   \end{array}
                   \right]
                 \end{array}
                 \right] %%! Should be \red
}\]

The resulting data-type is called $\HExprFreeD$. By a simple unfolding
of definition, we note that $\FreeIMonad{\HExprFreeD}{\Ty}{\Val{}}$
corresponds to the syntax of closed terms, $\HExprD$. Similarly,
$$\FreeIMonad{\HExprFreeD}{\Ty}{(\LAM{ty} \Val{ty} + \Var{dom}{ty})}$$
corresponds to expressions with variables, $\HExprVarD$.

\begin{wstructure}
    /> On open terms, we get a substitution
        -> Apply substI on assgnmt
            -> Have a well-typed language
            -> Get a safe evaluator 
                <- for well-typed terms 
                <- in well-typed contexts
\end{wstructure}

The evaluator for closed term we implemented in
Section~\ref{sec:idesc-examples} remains unchanged. It reduces closed
terms in $\FreeIMonad{\HExprFreeD}{\Ty}{\Val{}}\: ty$ to values in
$\Val{ty}$. We are therefore left with implementing $\substH$. We
simply have to fill in the right arguments to $\substI$, the type
guiding us:


\[\stk{
\begin{array}{@{}ll}
\substH  : & \PITEL{\V{ty}}{\Ty}
             \PITEL{\V{dom}}{\EnumU} 
             \PITEL{\V{\gamma}}{\spi{dom}{(\LAM{\_} \IMu{\Ty}{\toIDesc{\FreeIMonad{\HExprFreeD}{\Ty}{\Val{}}}}{ty})}} \\
           &  \PI{\V{\sigma}}{\PI{\V{ty}}{\Ty} (\Val{ty} + \Var{dom}{ty}) \To
                              \IMu{\Ty}{(\toIDesc{\FreeIMonad{\HExprFreeD}{\Ty}{\Val{}}})}{ty}} \\
           & \IMu{\Ty}{\toIDesc{\FreeIMonad{\HExprFreeD}{\Ty}{\Val{} + \Var{dom}{}}}}{\V{ty}} \To
             \IMu{\Ty}{\toIDesc{\FreeIMonad{\HExprFreeD}{\Ty}{\Val{}}}}{\V{ty}} \\
\end{array} \\
\substH\: ty\: dom\: \gamma\: \sigma\: term \mapsto 
    \substI\: \Ty\: 
              (\Val{} + \Var{dom}{})\: 
              \Val{}\:
              \HExprFreeD\:
              \sigma\:
              ty\:
              term
}\]

\note{Not using $\discharge$, that's a shame.}

Hence, we have completed our implementation of the evaluator for open
terms. We started with a well-typed language of arithmetical
expressions. We have seen how to take advantage of indexes to only
present type-safe constructors. Then, we have implemented an evaluator
for closed term, based on the generic catamorphism function. Having
implemented an open term representation, we wanted a substitution
operation, in order to close open terms in a context. Again, we have
implemented this operation with the generic substitution
operator. Hence, without much efforts, we have described the syntax of
a well-typed language, together with its semantics.

\begin{wstructure}
<- IDesc
    <- Another instance of free monad
        <- Var: Return
        <- Remaining: (not even indexed) functor
    -> Madness just starts
        <- map operation
        <- [ subst sigma D ] X = [D] (\x -> [subst sigma x] X)
        ???
\end{wstructure}

\paragraph{Indexed description:}

Another instance of free monad is $\IDesc$ itself. Indeed, $\DVar$ is
nothing but the ``return''. The remaining constructors are simply the
signature functor, trivially indexed by $\Unit$. Hence, we describe
this signature functor by the following code:

\[\stk{
\IDescFreeD : \PI{\V{I}}{\Set} \IDesc{\Unit} \\
\begin{array}{@{}ll}
\IDescFreeD~I \mapsto \DSigma{}{} & (\EnumT [ \DConst{},
                                              \DProd{}{},
                                              \DSigma{}{}, 
                                              \DPi{}{} ]) \\
                                  & \left[\begin{array}{l}
                                        \DConst{\Set}               \\
                                        \DProd{\DVar{\Void}}{\DVar{\Void}}  \\
                                        \DSigma{\Set}{(\LAM{S} \DPi{S}{(\LAM{\_} \DVar{\Void})})} \\
                                        \DSigma{\Set}{(\LAM{S} \DPi{S}{(\LAM{\_} \DVar{\Void})})}
                                    \end{array}\right]
\end{array}
}\]

Then, we get $\IDesc$ by building its free monad:

\[\stk{
\IDescD : \PI{\V{I}}{\Set} \IDesc{\Unit} \\
\IDescD\: I \mapsto \FreeIMonad{[\IDescFreeD]}{\Unit}{I}\: I
}\]


\note{ Should we stop here? Or show off some madness? }
