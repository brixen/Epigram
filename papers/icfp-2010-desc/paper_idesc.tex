\section{Indexing descriptions}

\begin{wstructure}
!!! Need Help !!!
<- Motivation
    <- Desc: expressivity of simply-typed data-types: inductive types
        <- Values do not influence types
    /> Example: Vectors
        <- Cannot be defined by just induction
            <- Vectors of all size need to be defined at the *same* time
            -> Defined as a *family* of types
                -> Index
        -> I -> IDesc I: Inductive family
    ???
\end{wstructure}

\note{ Need care: motivating motivation of indexing. }

So far, we have explored the well-known realm of inductive types. We
have built upon the experience gained in using simply-typed languages,
such as Haskell or OCaml. In our dependent setting, we provided these
data-types by the mean of $\Desc$, a universe of descriptions. 

While inductive types are the alpha and omega of the simply-typed
languages, evolving in a dependent setting fosters new
opportunities. The typical example is bounded lists, also known as
vectors. A vector is a list decorated by its length. Having this
information prevents hazardous operations, such as taking the head of
an empty vector: the head function only takes vectors of length
$\NatSuc{n}$, as enforced by its type. This is made possible by the
very specificity of dependently-typed systems: terms -- the length --
are allowed to influence types -- the vector type.

However, this new class of objects cannot be defined by mere
induction. In the case of vectors, for instance, we have to define the
whole \emph{family} of vector in one go: vectors of all size needs to
be defined at the same time. Where simply-typed languages have
inductive types, we adopt inductive family of types as our basic
grammar of data-types. To this end, we rely on \emph{indexing}. We are
going to transform the $\Desc$ universe into an indexed $\IDesc$
universe. We express inductive families by the $I \To \IDesc{I}$ type.


\subsection{From Desc to IDesc}

\begin{wstructure}
<- Labelling Id
    <- We had: data Desc : Set -> Set
    -> We want: data IDesc : (I -> Set) -> Set
        <- Indexed functor (?)
        -> It is sufficient to label Id
            <- Where the functor is built
\end{wstructure}

In the previous section, we have presented the $\Desc$ universe as the
grammar of functors in the category $\Set$. We have seen how to encode
inductive types in this setting. To encode an inductive family indexed
by $\Bhab{\V{I}}{\Set}$, we rely on functors in the category
$\Set^I$. We call these \emph{indexed functors}. When $\Desc$ was
defining a grammar a functor, we need $I \To \IDesc{I}$ to define a
grammar of indexed functors:

\[\stk{
\data \IDesc{} (\Bhab{\V{I}}{\Set}) : \Set \where \\
\;\;\ldots \\
\\
\idescop{\_\:}{}{} : \PI{\V{I}}{\Set} \IDesc{I} \To (\V{I} \To \Set) \To \Set    \\
\ldots
}\]

This generalisation can be achieved by a minor evolution of $\Desc$
(Fig.~\ref{fig:factor-desc}). Indeed, the functorial nature of $\Desc$
is entirely captured by the $\DId$ code. We get an indexed functor
by turning $\DId$ into an index-dependent $\DVar$ code:

\[\stk{
\data \IDesc{} (\Bhab{\V{I}}{\Set}) : \Set \where \\
\;\;\begin{array}{@{}l@{\::\:}l@{\quad}l}
    \DVar{}         & I \To \IDesc{I}                                   \\
    \ldots          & \ldots
\end{array} \\
\\
\idescop{\_\:}{}{} : \PI{\V{I}}{\Set} \IDesc{I} \To (\V{I} \To \Set) \To \Set        \\
\begin{array}{@{}l@{\:=\:\:}ll}
\idescop{\DVar{i}}{I}{P}      &  P~i                                                 \\
\ldots                        &  \ldots
\end{array}
}\]

\begin{wstructure}
<- Also replacing '1 by 'const  [figure]
    <- For convenience
        <- 'const X equivalent to 'sigma X (\_ -> '1)
        /> Easier to abstract
            <- Extensionally same
            /> 'const more useful in practice
\end{wstructure}

The resulting code of $\IDesc$ is presented in
Figure~\ref{fig:idesc}. The reader will notice that we have also
replaced $\DUnit$ by a more general $\DConst$ code. Whereas $\DUnit$
was interpreted as the unit set, $\DConst{X}$ is interpreted as $X$,
for any $\Bhab{X}{\Set}$. Extensionally, $\DConst{X}$ and
$\DSigma{X}{\DUnit}$ are equivalent. However, $\DConst$ is more
succinct. More importantly, $\DConst$ is \emph{first-order}, unlike
its equivalent encoding. From a definitional perspective, we are
giving more opportunities to the type-system, hence reducing the
burden on the programmer in practice.

\begin{figure*}

\[
\begin{array}{ll}
\stk{
\data \IDesc{} (\Bhab{\V{I}}{\Set}) : \Set \where \\
\;\;\begin{array}{@{}l@{\::\:}l@{\quad}l}
    \DVar{}         & I \To \IDesc{I}                                   \\
    \DConst{}       & \Set \To \IDesc{I}                                \\
    \DProd{}{}      & \PI{\V{D}, \V{D'}}{\IDesc{I}} \IDesc{I}           \\
    \DSigma         & \PI{\V{S}}{\Set} \PIS{S \To \IDesc{I}} \IDesc{I}  \\
    \DPi            & \PI{\V{S}}{\Set} \PIS{S \To \IDesc{I}} \IDesc{I} 
\end{array}
}
&
\stk{
\idescop{\_\:}{}{} : \PI{\V{I}}{\Set} \IDesc{I} \To (\V{I} \To \Set) \To \Set                  \\
\begin{array}{@{}l@{\:=\:\:}ll}
\idescop{\DVar{i}}{I}{P}      &  P~i                                                 \\
\idescop{\DConst{X}}{I}{P}    &  X                                                   \\
\idescop{\DProd{D}{D'}}{I}{P} &  \TIMES{\idescop{D}{I}{P}}{\idescop{D'}{I}{P}}       \\
\idescop{\DSigma{S}{D}}{I}{P} &  \SIGMA{\V{s}}{S} \idescop{D\: s}{I}{P}                    \\
\idescop{\DPi{S}{D}}{I}{P}    &  \PI{\V{s}}{S} \idescop{D\: s}{I}{P}            
\end{array}
}
\end{array}
\]

\caption{Universe of indexed description}
\label{fig:idesc}

\end{figure*}


\begin{structure}
<- Tagged constructor choice
    <- Index available when defining the data-type
        -> Can influence the choice of constructors
        -> Dependently-typed data-types
            <- term (index) influence types
    -> Two parts
        <- Always on the menu
            <- E : EnumU 
            <- ED : E -> IDesc I
        <- Index-dependent
            <- F : I -> EnumU 
            <- FD : (i : I) -> spi (F i) (\_ -> IDesc I)
        -> taggedIDesc I == Sigma E ED x Sigma F FD
        -> toIDesc : (I : Set) -> taggedIDesc I -> (I -> IDesc I)
\end{structure}

In Section~\ref{sec:desc-examples}, we have defined a \emph{tagged}
form for descriptions. This format follows the usual presentation of
inductive types as sums of product. With indexed description, this
definition can be generalized. Indeed, when defining an indexed
data-type, we have access to this index. Therefore, we can use this
index to influence the choice of constructors. This captures the
essence of dependent data-types: a term -- the index -- has the
ability to influence the data-type.

For convenience, we divide a tagged indexed description in two parts:
first, the constructors that do not depend on the index; then, the
constructors that do. The non-dependent part mirrors the definition
for non-indexed descriptions: we are provided a finite choice of
constructors. The index-depend part simply indexes the choice of
constructors by $I$. Hence, by inspecting the index, it is possible to
enable or disable the constructors. 

\[\stk{
 \ATagIDesc{I} \mapsto \SIGMA{\V{E}}{\EnumU} (\spi{\V{E}}{(\LAM{\_} \IDesc{I})}) \\
 \ITagIDesc{I} \mapsto \SIGMA{\V{F}}{I \To \EnumU} (\PI{\V{i}}{I} \spi{(F\: i)}{(\LAM{\_} \IDesc{I})})  \\
 \TagIDesc{I}  \mapsto \TIMES{\ATagIDesc{I}}{\ITagIDesc{I}}
}\]

In the case of vectors, for instance, for the index $n = \NatZero$, we
would only offer the constructor $\ListNil$. Similarly, for $n =
\NatSuc{n'}$, we only offer the constructor $\ListCons{}{}$. We will
see more instances of this pattern in the following.



\note{Should we say something about IMu, fixed-points, and their
  elimination before moving on? If so, where should we put it?}


\subsection{Examples}
\label{sec:idesc-examples}

\begin{wstructure}
<- Nat
    -> [equation]
    <- Non-indexed types lives in IDesc 1
        -> This applies to all previous examples
\end{wstructure}

In order to gain some intuition with $\IDesc$, let us re-implement the
signature functor of natural numbers. We refer the reader to
Section~\ref{sec:desc-examples} for its incarnation in the universe of
descriptions. The code is the following:

\[\stk{
\NatD : \IDesc{\Unit} \\
\NatD \mapsto \DSigma{(\EnumT [ \NatZero, \NatSuc{} ])}
                     {[ \DConst{\Unit} \quad (\DVar{\Void}) ]}
}\]

Because $\Nat$ is just an inductive type, we make no use of the index:
it is the trivial inhabitant of $\Unit$. Therefore, the recursive
argument is materialised by $\DVar{\Void}$, where we were using $\DId$
in the $\Desc$ presentation. This transformation applies to all
inductive types: we have not lost in expressive power during the
transition.

\begin{wstructure}
<- Levitation [figure]
    <- Following Desc encoding
        /> Note: simple data-type
            -> Live in IDesc 1
    -> Behind the scene, relies on the special purpose switchD
\end{wstructure}

A mandatory exercise consists in describing $\IDesc$ in itself. With
the experience gained in Section~\ref{sec:desc-levitate}, this
levitation does not pose any issue:

\[\stk{
\IDescD : \PI{\V{I}}{\Set} \IDesc{\Unit} \\
\begin{array}{@{}ll}
\IDescD~I \mapsto \DSigma{}{} & (\EnumT [ \DVar{},
                                          \DConst{},
                                          \DProd{}{},
                                          \DSigma{}{}, 
                                          \DPi{}{} ]) \\
                              & \left[\begin{array}{l}
                                      \DConst{I}                  \\
                                      \DConst{\Set}               \\
                                      \DProd{\DVar{\Void}}{\DVar{\Void}}  \\
                                      \DSigma{\Set}{(\LAM{S} \DPi{S}{(\LAM{\_} \DVar{\Void})})} \\
                                      \DSigma{\Set}{(\LAM{S} \DPi{S}{(\LAM{\_} \DVar{\Void})})}
                                   \end{array}
                             \right]
\end{array}
}\]

Note that this description also lives in $\IDesc{\Unit}$. Indeed,
$\IDesc$ is merely an inductive type. As for the $\Desc$ levitation,
the finite function space $[ \ldots ]$ elaborates into a special
purpose $\F{switchID}$ operator. 


\begin{structure}
<- Hutton's razor
    <- Types
        <- 'Nat
        <- 'Bool
    <- Term [figure]
        <- val : Val a -> 'a  for Val : Ty -> Set, mapping to Nat and Bool
        <- cond : 'Bool -> a -> a -> a
        <- plus : 'Nat -> 'Nat -> 'Nat
        <- le : 'Nat -> 'Nat -> 'Bool
    -> evaluation: IMu TermD -> Val
        -> it is a catamorphism
            <- Look closer at the type
        -> implementation [code]
            <- Just define one reduction step
            -> cata does the rest
                /> cata is for free!
    /> Closed term
        <- only constants and operations on them
        -> Extend Val with Var : Ty -> Set, mapping to EnumU
            -> Open term
            -> Language of well-typed terms
                <- By construction
        <- evaluator, with a context
            -> First, close variables
                -> Perform assignment
                <- subst [code]
            /> Then, perform subst everywhere in the term
                -> Show type [code]
                /> This is a bind!?
                -> There is some more structure 
                    -> We should try to get it
\end{structure}


\note{Begging for a transition here.}

\subsection{Constrained constructors}

\begin{wstructure}
!!! Need Help !!!
<- Assuming a suitable notion of definitional equality for I
    ???
\end{wstructure}

However, before entering the realm of generic structures, let us
further explore the universe of indexed descriptions. In the
following, we ask $I$ to come equipped with a notion of definitional
equality. Hence, we can legibly equates elements of $I$.

\note{ I will need some tutorial on this ad-hoc notion of definitional
  equality. Or what Conor's meant with that. }

\begin{wstructure}
<- Fin [figure]
    <- Presentation with equality constraints
    <- Example of constrained constructor
        -> Constraints are translated into equalities
    ???
\end{wstructure}
 
In our implementation of lambda terms, variables were elements of
$\Fin{n}$, with $n$ the number of binders. Let us now implement
$\Fin$. $\Fin$ is a typical example of an inductive family using
\emph{constrained constructors}. The constructors $\FinZero$ and
$\FinSuc$ are only defined for an index distinct from $\NatZero$:

\[
\Rule{\Bhab{n}{\Nat}}
     {\Bhab{\FinZero}{\Fin{(\NatSuc{n})}}}
\qquad
\Rule{\Bhab{n}{\Nat} \quad 
      \Bhab{i}{\Fin{n}}}
     {\Bhab{\FinSuc{}}{\Fin{(\NatSuc{n})}}}
\]

In order to code this data-type, we have to appeal to equality:

\[\stk{
\FinD : \Nat \To \IDesc{\Nat} \\
\begin{array}{@{}ll}
\FinD\: n = \DSigma{}{} & (\EnumT [ \FinZero , \FinSuc{} ]) \\
                        & \left[
                          \begin{array}{l}
                            \DSigma{\Nat}{\LAM{m} \DConst{(n \PropEq \NatSuc{m})}} \\
                            \DSigma{\Nat}{\LAM{m} \DProd{\DVar{m}}{\DConst{(n \PropEq \NatSuc{m})}}}
                          \end{array}
                          \right]
\end{array}
}\]

Intuitively, the constraint is captured as follow. First, we store an
element $m$ of $\Nat$, thanks to a $\DSigma$. However, the constraint
stipulates that $m$ cannot be \emph{any} natural numbers: it must be
``the index minus one''. This translates into the constraint $n
\PropEq \NatSuc{m}$. 

\note{ Anything else? }

\begin{wstructure}
<- Vectors
    Do we treat them in the end? 
    What can we say here we haven't with Fin?
\end{wstructure}

\note{ I suspect we don't implement vectors, space-wise }

\begin{wstructure}
<- GADT-style data-type definition
    <- We directly support it
        <- Constraints turned into equalities
            <- Fin example
    <- Again, smooth transition from "today" data-types to advanced ones
        <- Same grammar
        /> More power
    /> Equations in data-types are not a blessing
        <- Complexify induction principle
        <- Lose match between data-type definition and the elimination form
\end{wstructure}

The $\Fin$ example is also a well-known example of Generalised
Abstract Data-Type (GADT), in Haskell. It comes as no surprise that
our universe of indexed description supports this restricted class of
dependent data-types. As we have shown with $\Fin$, constrained
constructors are straightforwardly translated into equality
constraints.

While we support the same grammar, indexed descriptions embraces a
much wider class of data-types. Indeed, we pose no constraint apart
from strict positivity. This suggests that, based on the familiar
grammar of GADTs, we can simply lift off the restrictions and
translates the user's input to a code in our universe of indexed
description. 

However, one could, quite rightfully, be worried by the introduction
of equations in the picture. In the context of programming, these
equations will come back and haunt us, begging for proofs. Hence,
whereas the user typed a constructor-constrained data-type, the
elimination form will involve equations and their proofs. This
introduces a loophole in our abstraction we should try to address.

\note{Is that convincing? Worth saying? Anything else?}

\begin{wstructure}
!!! Need Help !!!
<- Brady optimisation: forcing
    <- Source to source translation
    <- Able to remove some constraints
    -> Example: Fin [figure]
    ??? More technical detail needed
\end{wstructure}

To get a clue of a solution, let us look back at $\Fin$. We note that
the equation is introduced because we are \emph{storing} the index of
the inductive family, through $m$. Hence the constraint. However,
\emph{inductive families need not store their
  indices}~\cite{brady:index-inductive-families}. Applying the
\emph{forcing} optimisation to our definition of $\Fin$ gives the
following, equivalent definition:

\note{ I'm not familiar with this, I need to get into the paper. }

\[\stk{
\FinD : \Nat \To \IDesc{\Nat} \\
\begin{array}{@{}llll}
\FinD\: 0            & = & \multicolumn{2}{l}{\DSigma{\Void}{\Void} } \\
\FinD\: (\NatSuc{n}) & = & \DSigma{}{} & (\EnumT [ \FinZero , \FinSuc{} ]) \\
                     &   &             & \left[
                                         \begin{array}{l}
                                         \DConst{\Unit} \\
                                         \DVar{n}
                                         \end{array}
                                         \right]
\end{array}
}\]

Equations have simply disappeared! We should precise that forcing a
description is not guaranteed to remove all constraints. It is subject
of future work to see if constraints can be entirely eradicated, or
presented more conveniently to the user.

Finally, it is worth mentioning that the forcing optimisation is a
\emph{source-to-source} transformation of the description. 

\note{ Actual implementation of forcing as a generic function??! }

\subsection{Free IMonad}

\begin{wstructure}
<- Variation on a theme: free imonad construction
    <- Recall existence of generic free monad construction
    -> Present its generalisation to IDesc [equation]
        <- \I -> IDesc I as describing an indexed endofunctor
        <- Free monad construction
    -> Still a suitable, generic notion of substitution
        <- show type signature
        <- show implementation?? (space! space!)
\end{wstructure}

In this section, we develop some more structure for our indexed
data-types. In Section~\ref{sec:desc-free-monad}, we have constructed
a free monad operation on simple descriptions. Building on this
experience, we are going to present its equivalent in the indexed
world. The processus is the same. Namely, given an indexed functor, we
derive the indexed functor coding its free monad:

\[\stk{
\begin{array}{ll}
\FreeIMonad{\_}{} : & \PITEL{\V{I}}{\Set}
                      \PITEL{\V{X}}{\V{I} \To \Set} \\
                    & \PITEL{\V{R}}{\V{I} \To \TagIDesc{I}} \To
                      (\V{I} \To \TagIDesc{I})
\end{array} \\
\FreeIMonad{R}{I}{X} \mapsto
    \LAM{i}
    \pair{\ListCons{\DVar{}}{(\fst{(R\: i)})}}
         {\pair{(\DConst{X\: i})}
               {(\snd{(R\: i)})}{}}{}
}\]

Just as in the universe of descriptions, this construction comes with
an obvious ``return'' and a substitution operation, the ``bind''. Its
type signature is the following:

\newcommand{\substI}{\F{substI}}

\[
\begin{array}{@{}ll}
\substI : & \PITEL{\V{I}}{\Set}
            \PITEL{\V{X}, \V{Y}}{\V{I} \To \Set}
            \PITEL{\V{R}}{\V{I} \To \TagIDesc{\V{I}}} \\
          & \PITEL{\V{\sigma}}{\PI{\V{i}}{\V{I}} \V{X}\:\V{i} \To 
                               \IMu{I}{(\FreeIMonad{\V{R}}{\V{I}}{\V{Y}})}{\V{i}}} \\
          & \PITEL{\V{i}}{\V{I}}
            \PITEL{\V{D}}{\IMu{I}{(\FreeIMonad{\V{R}}{\V{I}}{\V{X}})}{\V{i}}} \To
            \IMu{I}{(\FreeIMonad{\V{R}}{\V{I}}{\V{Y}})}{\V{i}}
\end{array}
\]


\subsubsection{Examples}


\begin{structure}
<- Hutton's razor is a free monad
    <- substI was our candidate bind
        -> Massage the definition of expr to get it for free
    <- Finding the functor
        <- 'val is the return
        <- The other components are the action
        -> Updated tagged description [figure]
    -> Compute the free monad Hutton * X
        -> With X = Val: We get back our closed terms
        -> With X = Val + Var vars: We get back our open terms
    /> On open terms, we get a substitution
        -> Apply substI on assgnmt
            -> Have a well-typed language
            -> Get a safe evaluator 
                <- for well-typed terms 
                <- in well-typed contexts
\end{structure}


\begin{wstructure}
<- IDesc
    <- Another instance of free monad
        <- Var: Return
        <- Remaining: (not even indexed) functor
    -> Madness just starts
        <- map operation
        <- [ subst sigma D ] X = [D] (\x -> [subst sigma x] X)
        ???
\end{wstructure}

Another instance of free monad is $\IDesc$ itself. Indeed, $\DVar$ is
nothing but the ``return''. The remaining constructors are simply the
freed functor, trivially indexed by $\Unit$. Hence, amusingly, we can
define the $\IDesc$ freed functor by the following code:

\[\stk{
\IDescFreeD : \PI{\V{I}}{\Set} \IDesc{\Unit} \\
\begin{array}{@{}ll}
\IDescFreeD~I \mapsto \DSigma{}{} & (\EnumT [ \DConst{},
                                              \DProd{}{},
                                              \DSigma{}{}, 
                                              \DPi{}{} ]) \\
                                  & \left[\begin{array}{l}
                                        \DConst{\Set}               \\
                                        \DProd{\DVar{\Void}}{\DVar{\Void}}  \\
                                        \DSigma{\Set}{(\LAM{S} \DPi{S}{(\LAM{\_} \DVar{\Void})})} \\
                                        \DSigma{\Set}{(\LAM{S} \DPi{S}{(\LAM{\_} \DVar{\Void})})}
                                    \end{array}\right]
\end{array}
}\]

Then, we get $\IDesc$ by building its free monad:

\[\stk{
\IDescD : \PI{\V{I}}{\Set} \IDesc{\Unit} \\
\IDescD\: I \mapsto \FreeMonad{[\IDescFreeD]}{I}\: I
}\]


\note{ Should we stop here? Or show off some madness? }
