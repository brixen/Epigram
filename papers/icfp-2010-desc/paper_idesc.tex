\section{A Universe of Inductive Families}
\label{sec:indexing-desc}

\begin{wstructure}
!!! Need Help !!!
<- Motivation
    <- Desc: expressivity of simply-typed datatypes: inductive types
        <- Values do not influence types
    /> Example: Vectors
        <- Cannot be defined by just induction
            <- Vectors of all size need to be defined at the *same* time
            -> Defined as a *family* of types
                -> Index
        -> I -> IDesc I: Inductive family
    ???
\end{wstructure}

So far, we have explored the well-known realm of inductive types. We
have built upon our intuition of ML-like datatypes. In our dependent
setting, we have provided these datatypes by the mean of $\Desc$, a
universe of descriptions.

Working with dependent types fosters new opportunities for
datatypes. The typical example is bounded lists, also known as
vectors. A vector is a list decorated by its length. Having this
information prevents hazardous operations, such as taking the head of
an empty vector: the head function only takes vectors of length
$\NatSuc{\V{n}}$, as enforced by its type. This is made possible by
the specificity of dependent types: a term -- the length -- can
influence a type -- the vector type.

However, these datatypes cannot be defined by mere induction. In the
case of vectors, for instance, we have to define the whole
\emph{family} of vectors in one go: vectors of all sizes need to be
defined at the same time. In dependently-typed languages, the basic
grammar of datatypes is that of inductive families. To capture this
grammar, we rely on \emph{indexing}.

%% \subsection{Desc, atomically}
%% \label{sec:idesc-atomic-desc}

%% \begin{wstructure}
%% [Outdated: type former presentation instead]
%% <- Adding hindx have introduced some duplication
%%     <- indx == hindx 1
%%     -> We can factor out commonalities 
%%         /> Obtain an equivalent presentation
%%         /> Still embeddable (refer to the Agda model)
%% \end{wstructure}

%% \begin{wstructure}
%% <- Also replacing '1 by 'const  [figure]
%%     <- For convenience
%%         <- 'const X equivalent to 'sigma X (\_ -> '1)
%%         /> Easier to abstract
%%             <- Extensionally same
%%             /> 'const more useful in practice
%% \end{wstructure}

%% Before moving on to indexed descriptions, we have to carry out some
%% maintenance work on descriptions. We presented $\Desc$ as the grammar
%% of inductive types. Hence, the codes closely follow this grammar. In
%% the following, we adopt an alternative presentation. With
%% $\DSigma{\!}{\!}$, we are actually \emph{quoting} a standard
%% type-former, namely

%% $$\Bhab{\Sigma}{\PI{\V{S}}{\Set} \PI{\V{S}}{\Set} \Set}$$

%% In the alternative presentation, we go further and present all our
%% codes as quotations of standard type-formers. This presentation is
%% shown in Figure~\ref{fig:type-former-desc}. The reader will notice
%% that we replace $\DUnit$ by a more general $\DConst{\!}$ code. Whereas
%% $\DUnit$ was interpreted as the unit set, $\DConst{\V{X}}$ is
%% interpreted as $\V{X}$, for any $\Bhab{\V{X}}{\Set}$. Extensionally,
%% $\DConst{\V{X}}$ and $\DSigma{\V{X}}{\DUnit}$ are equivalent. However,
%% $\DConst{\!}$ is more succinct. More importantly, $\DConst$ is
%% \emph{first-order}, unlike its equivalent encoding. From a
%% definitional perspective, we are giving more opportunities to the
%% type-system, hence reducing the burden on the programmer. For the same
%% reason, we introduce $\DProd{\!}{\!}$ that overlaps with
%% $\DSigma{\!}{\!}$.

%% This reorganisation is strictly equivalent to the previous one
%% (Fig.~\ref{fig:hindx_desc}). Just as the previous version, it is also
%% self-descriptive. We refer the reader to the companion technical
%% report for details. In this finer-grained presentation, we can define
%% $\DIndx{\!}$ and $\DHindx{\!}{\!}$ as follow:

%% \[\begin{array}{l@{\:\mapsto\:\:}l}
%% \DIndx{\V{D}}         & \DProd{\DId}{\V{D}}                      \\
%% \DHindx{\V{H}}{\V{D}}     & \DProd{(\DPi{\V{H}}{(\LAM{\_} \DId)})}{\V{D}}
%% \end{array}
%% \]

%% Consequently, the examples previously developed can be
%% straightforwardly translated into this new presentation. For example,
%% here is the new definition of $\NatD$:

%% \[\stk{
%% \NatD : \Desc \\
%% \NatD \mapsto \DSigma{(\EnumT{[ \NatZero, \NatSuc{\!} ]})}
%%                      {[ \DUnit \quad \DId ]}
%% }\]


%% In the following, we adopt this last version as our de
%% facto universe of inductive types. In particular, we are going to
%% evolve this presentation into an indexed one.

%% \note{Shall we talk about the Type Theory being Desc Zero? or such story?}

%% \begin{figure}

%% \[\stk{
%% \begin{array}{ll}
%% \stk{
%% \data \Desc : \Set \where                                      \\
%% \;\;\begin{array}{@{}l@{\::\:\:}l@{\quad}l}
%%     \DId            & \Desc                                    \\
%%     \DConst{\!}     & \Set \To \Desc                           \\
%%     \DProd{\!}{\!}  & \PI{\V{D}, \V{D'}}{\Desc} \Desc          \\
%%     \DSigma{\!}{\!} & \PI{\V{S}}{\Set} \PIS{\V{S} \To \Desc} \Desc \\
%%     \DPi{\!}{\!}    & \PI{\V{S}}{\Set} \PIS{\V{S} \To \Desc} \Desc 
%% \end{array}
%% }
%% \vspace{0.2in}
%% \\
%% \stk{
%% \descop{\_\:}{} : \Desc \To \Set \To \Set \\
%% \begin{array}{@{}l@{\:=\:\:}ll}
%% \descop{\DId}{\V{X}}          &  \V{X}                                           \\
%% \descop{\DConst{\V{Z}}}{\V{X}}    &  \V{Z}                                           \\
%% \descop{\DProd{\V{D}}{\V{D'}}}{\V{X}} &  \TIMES{\descop{\V{D}}{\V{X}}}{\descop{\V{D}\V{'}}{\V{X}}}       \\
%% \descop{\DSigma{\V{S}}{\V{D}}}{\V{X}} &  \SIGMA{\V{s}}{\V{S}} \descop{\V{D}\: \V{s}}{\V{X}}          \\
%% \descop{\DPi{\V{S}}{\V{D}}}{\V{X}}    &  \PI{\V{s}}{\V{S}} \descop{\V{D}\: \V{s}}{\V{X}}            
%% \end{array}
%% }
%% \end{array}
%% }\]

%% \caption{Universe of descriptions based on Type-formers}
%% \label{fig:type-former-desc}

%% \end{figure}

\subsection{The universe of indexed descriptions}

\begin{wstructure}
<- Labelling Id
    <- We had: data Desc : Set -> Set
    -> We want: data IDesc : (I -> Set) -> Set
        <- Indexed functor (?)
        -> It is sufficient to label Id
            <- Where the functor is built
\end{wstructure}

In the previous section, we have presented the $\Desc$ universe as a
grammar of functors in the category $\Set$. We have seen how to code
inductive types in this setting. To describe an inductive family
indexed by $\Bhab{\V{I}}{\Set}$, we use endofunctors on the category
$\Set^{\V{I}}$. We call these \emph{indexed functors}. \note{Predicate
  transformer anyone?} $\V{I} \To \IDesc{\V{I}}$ is our grammar for
describing these functors. Hence, $\IDesc{\!}$ and its interpretation
have the following types:
%
\[\stk{
\IDesc{(\Bhab{\V{I}}{\Set})} : \Set \smallskip \\
\idescop{\_}{}{} : _{\PI{\V{I}}{\Set}} \IDesc{\V{I}} \To (\V{I} \To \Set) \To \Set    \\
}\]

Given these components, we may interpret a \emph{function}
$\V{R}:\V{I} \To \IDesc{\V{I}}$ is interpreted as a function
$\V{I} \To \Set^{\V{I}} \To \Set$, which is isomorphic to $\Set^{\V{I}}
\To \Set^{\V{I}}$, the type of endofunctors on \(\Set^{\V{I}}\).
Inductive families are fixpoints defined over
these indexed functors, hence computing a fixpoint of the entire
\emph{family} of functors:
%
\[\stkl{
\Rule{\Gamma \vdash \Bhab{\V{I}}{\Set} \qquad
      \Gamma \vdash \Bhab{\V{R}}{\V{I} \To \IDesc{\V{I}}}}
     {\Gamma \vdash \Bhab{\IMu{\V{I}}{\V{R}}{\!}}{\V{I}\To\Set}} \qquad
\\
\Rule{\begin{array}{l@{\qquad}l}
          \Gamma \vdash \Bhab{\V{I}}{\Set} &
          \Gamma \vdash \Bhab{\V{R}}{\V{I} \To \IDesc{\V{I}}} \\
          \Gamma \vdash \Bhab{\V{i}}{\V{I}} &
          \Gamma \vdash \Bhab{\V{x}}{\idescop{\V{R}\:\V{i}}{\V{I}}{(\IMu{\V{I}}{\V{R}}{\!})}}
      \end{array}}
     {\Gamma \vdash \Bhab{\Con{\V{x}}}{\IMu{\V{I}}{\V{R}}{\V{i}}}}
}\]

\newcommand{\inductionI}{\F{indI}}
\newcommand{\cataI}{\F{cataI}}

However, we still have to define the actual grammar. We obtain it by
evolving $\Desc$ to cope with indexing. \note{Say something about the
  transformation} The code of $\IDesc{\!}$ is presented in
Figure~\ref{fig:idesc}. Induction on indexed descriptions is defined
by:
%
\[\stk{
\begin{array}{@{}ll}
\inductionI : & _{\PI{\V{I}}{\Set}}
                   \PITEL{\V{R}}{\V{I} \To \IDesc{\V{I}}}
                   \PI{\V{P}}{(\SIGMAS{\Bhab{\V{i}}{\V{I}}}{\IMu{\V{I}}{\V{R}}{\V{i}}}) \To \Set} \\
                 & (      \PITEL{\V{i}}{\V{I}} 
                          \PI{\V{xs}}{\idescop{\V{R}\: \V{i}}{\V{I}}{(\IMu{\V{I}}{\V{R}}{\!})}} \\
                 & \   \idescop{\AllI{}
                                     {(\V{R}\: \V{i})}
                                     {(\IMu{\V{I}}{\V{R}}{\!})}
                                     {\V{xs}}}
                               {}
                               {\V{P}} \To
                       \V{P}\: \pair{\V{i}}{\Con{\V{xs}}}{}) \To \\
                 & \PITEL{\V{i}}{\V{I}}
                   \PI{\V{x}}{\IMu{\V{I}}{\V{R}}{\V{i}}}
                   \V{P}\: \pair{\V{i}}{\V{x}}{}
\end{array} \\
\inductionI\: \V{R}\: \V{P}\: \V{m}\: \V{i}\: (\Con{\V{xs}}) =  \\
\qquad
    \V{m}\: \V{i}\: \V{xs}\: (\allI{}
                                    {\V{R}\: \V{i}}
                                    {\IMu{\V{I}}{\V{R}}{}}
                                    {\V{P}}
                                    {(\spl{\LAM{\V{i}}\LAM{\V{xs}} \inductionI\: \V{R}\: \V{P}\: \V{m}})}
                                    {\V{xs}})
}\]
%
Where the operators $\AllI{}{\!}{\!}{}$ and
$\allI{}{\!}{\!}{\!}{\!}{}$ are presented in
Figure~\ref{fig:allI-predicates}. As for descriptions, we can compute
a generic catamorphism, $\cataI$, from $\inductionI$.


\begin{figure*}

\[
\begin{array}{ll}
%%
\stk{
\begin{array}{@{}ll}
\AllI{\!}{\!}{\!}{\!} : & _{\PI{\V{I}}{\Set}}
                          \PITEL{\V{D}}{\IDesc{\V{I}}}
                          \PI{\V{X}}{\V{I} \To \Set} \\
                        & \idescop{\V{D}}{\V{I}}{\V{X}} \To
                          \IDesc{(\TIMES{\V{I}}{\V{X}})}
\end{array} \\
\begin{array}{@{}l@{}l@{\:=\:\:}l}
\AllI{\:}{(\DVar{\V{i}})}{& \V{X}}{\V{x}} &
    \DVar{\pair{\V{i}}{\V{x}}{}} \\
\AllI{\:}{(\DConst{\V{K}})}{& \V{X}}{\V{k}} &
    \DConst{\V{K}} \\
\AllI{\:}{(\DProd{\V{D}}{\V{D'}})}{& \V{X}}{\pair{\V{d}}{\V{d'}}{}} &
    \DProd{\AllI{}{\V{D}}{\V{X}}{\V{d}}}{\AllI{}{\V{D'}}{\V{X}}{\V{d'}}} \\
\AllI{\:}{(\DSigma{\V{S}}{\V{D}})}{& \V{X}}{\pair{\V{s}}{\V{d}}{}} &
    \AllI{}{(\V{D}\: \V{s})}{\V{X}}{\V{d}} \\
\AllI{\:}{(\DPi{\V{S}}{\V{D}})}{& \V{X}}{\V{f}} &
    \DPi{\V{S}}{(\LAM{\V{s}} \AllI{}{(\V{D}\: \V{s})}{\V{X}}{(\V{f}\: \V{s})})}
\end{array}
}
&
%%
\stk{
\begin{array}{@{}ll}
\allI{\!}{\!}{\!}{\!}{\!}{\!} : & _{\PI{\V{I}}{\Set}}
                                  \PITEL{\V{D}}{\IDesc{\V{I}}}
                                  \PITEL{\V{X}}{\V{I} \To \Set} 
                                  \PI{\V{P}}{\TIMES{\V{I}}{\V{X}} \To \Set} \\
                                & (\PI{\V{x}}{\TIMES{\V{I}}{\V{X}}} \V{P}\: \V{x}) \To
                                  \PI{\V{xs}}{\idescop{\V{D}}{\V{I}}{\V{X}}} 
                                  \idescop{\AllI{}{\V{D}}{\V{X}}{\V{xs}}}{\TIMES{\V{I}}{\V{X}}}{\V{P}}
\end{array} \\
\begin{array}{@{}l@{}l@{\:=\:\:}l}
\allI{\:}{(\DVar{\V{i}})}{& \V{X}}{\V{P}}{\V{p}}{\V{x}} &
    \V{p}\: \pair{\V{i}}{\V{x}}{} \\
\allI{\:}{(\DConst{\V{K}})}{& \V{X}}{\V{P}}{\V{p}}{\V{k}} &
    \V{k} \\
\allI{\:}{(\DProd{\V{D}}{\V{D'}})}{& \V{X}}{\V{P}}{\V{p}}{\pair{\V{d}}{\V{d'}}{}} &
    \pair{\allI{}{\V{D}}{\V{X}}{\V{P}}{\V{p}}{\V{d}}}
         {\allI{}{\V{D'}}{\V{X}}{\V{P}}{\V{p}}{\V{d'}}}{} \\
\allI{\:}{(\DSigma{\V{S}}{\V{D}})}{& \V{X}}{\V{P}}{\V{p}}{\pair{\V{s}}{\V{d}}{}} &
    \allI{}{(\V{D}\: \V{s})}{\V{X}}{\V{P}}{\V{p}}{\V{d}} \\
\allI{\:}{(\DPi{\V{S}}{\V{D}})}{& \V{X}}{\V{P}}{\V{p}}{\V{f}} &
    \allI{}{(\V{D}\: \V{a})}{\V{X}}{\V{P}}{\V{p}}{(\V{f}\: \V{a})}
\end{array}
\end{array}
}
\]

\caption{Indexed induction predicates}
\label{fig:allI-predicates}

\end{figure*}


%% \[\stk{
%% \data \IDesc{} (\Bhab{\V{I}}{\Set}) : \Set \where \\
%% \;\;\begin{array}{@{}l@{\::\:\:}l@{\quad}l}
%%     \DVar{}         & I \To \IDesc{I}                                   \\
%%     \ldots          & \ldots
%% \end{array} \\
%% \\
%% \idescop{\_\:}{}{} :_{\PI{\V{I}}{\Set}} \IDesc{I} \To (\V{I} \To \Set) \To \Set        \\
%% \begin{array}{@{}l@{\:=\:\:}ll}
%% \idescop{\DVar{i}}{I}{P}      &  P~i                                                 \\
%% \ldots                        &  \ldots
%% \end{array}
%% }\]

\begin{figure}

\[\stk{\begin{array}{@{}ll}
\IDesc{(\Bhab{\M{I}}{\Set})} &: \Set \\
\DVar{(\Bhab{\M{i}}{\M{I}})} &: \IDesc{\M{I}} \\
\DConst{(\Bhab{\M{A}}{\Set})} &:\IDesc{\M{I}}       \\
\DProd{(\Bhab{\M{D}}{\IDesc{\M{I}}})}{(\Bhab{\M{D}}{\IDesc{\M{I}}})}
  & :\IDesc{\M{I}}       \\
\DSigma{(\Bhab{\M{S}}{\Set})}{(\Bhab{\M{D}}{\M{S}\To\IDesc{\M{I}}})}
& : \IDesc{\M{I}}  \\
\DPi{(\Bhab{\M{S}}{\Set})}{(\Bhab{\M{D}}{\M{S}\To\IDesc{\M{I}}})}
& : \IDesc{\M{I}}  \\
\end{array}\smallskip \\
\idescop{\_\:}{}{} :_{\PI{\V{I}}{\Set}} \IDesc{\V{I}} \To (\V{\V{I}} \To \Set) \To \Set                  \\
\begin{array}{@{}l@{\V{X}}@{\:\mapsto\:\:}ll}
\idescop{\DVar{\V{i}}}{\V{I}}{&}      &  \V{X}\: \V{i}                                           \\
\idescop{\DConst{\V{K}}}{\V{I}}{&}    &  \V{K}                                                   \\
\idescop{\DProd{\V{D}}{\V{D'}}}{\V{I}}{&} &  \TIMES{\idescop{\V{D}}{\V{I}}{\V{X}}}{\idescop{\V{D'}}{\V{I}}{\V{X}}}       \\
\idescop{\DSigma{\V{S}}{\V{D}}}{\V{I}}{&} &  \SIGMA{\V{s}}{\V{S}} \idescop{\V{D}\: \V{s}}{\V{I}}{\V{X}}                    \\
\idescop{\DPi{\V{S}}{\V{D}}}{\V{I}}{&}    &  \PI{\V{s}}{\V{S}} \idescop{\V{D}\: \V{s}}{\V{I}}{\V{X}}            
\end{array}
}
\]

\caption{Universe of indexed descriptions}
\label{fig:idesc}

\end{figure}

%\subsection{Tagged indexed descriptions}

% This discussion seemed out of place to me, so i've moved it a bit later (pwm).

%\begin{wstructure}
%<- Tagged constructor choice
%    <- Index available when defining the datatype
%        -> Can influence the choice of constructors
%        -> Dependently-typed datatypes
%            <- term (index) influence types
%    -> Two parts
%        <- Always on the menu
%            <- E : EnumU 
%            <- ED : E -> IDesc I
%        <- Index-dependent
%            <- F : I -> EnumU 
%            <- FD : (i : I) -> spi (F i) (\_ -> IDesc I)
%        -> taggedIDesc I == Sigma E ED x Sigma F FD
%        -> toIDesc : (I : Set) -> taggedIDesc I -> (I -> IDesc I)
%\end{wstructure}
%
%In Section~\ref{sec:desc-examples}, we have defined a \emph{tagged}
%form for descriptions. This format follows the usual presentation of
%inductive types as sum-of-product. With indexed description, this
%definition can be generalized. Indeed, when defining an indexed
%datatype, we have access to this index. Therefore, we can use this
%index to influence the choice of constructors. This captures the
%essence of dependent datatypes: a term -- the index -- has the
%ability to influence the datatype.
%
%For convenience, we divide a tagged indexed description in two parts:
%first, the constructors that do not depend on the index; then, the
%constructors that do. The non-dependent part mirrors the definition
%for non-indexed descriptions: we are provided a finite choice of
%constructors. The index-depend part simply indexes the choice of
%constructors by $I$. Hence, by inspecting the index, it is possible to
%enable or disable the constructors. 
%
%\[\stk{
% \TagIDesc{\V{I}}  \mapsto \TIMES{\ATagIDesc{\V{I}}}{\ITagIDesc{\V{I}}} \\
% \ATagIDesc{\V{I}} \mapsto \SIGMA{\V{E}}{\EnumU} (\PI{\V{i}}{\V{I}} \spi{\V{E}}{(\LAM{\_} \IDesc{\V{I}})}) \\
% \ITagIDesc{\V{I}} \mapsto \\
%\qquad\SIGMA{\V{F}}{\V{I} \To \EnumU} (\PI{\V{i}}{\V{I}} \spi{(\V{F}\: \V{i})}{(\LAM{\_} \IDesc{\V{I}})}) 
%}\]
%
%
%\begin{wstructure}
%<- Vectors
%    Do we treat them in the end? 
%    What can we say here we haven't with Fin?
%\end{wstructure}
%
%In the case of vectors, for instance, for the index $\NatZero$, we
%would only propose the constructor $\ListNil$. Similarly, for
%$\NatSuc{n}$, we only propose the constructor $\ListCons{\!}{\!}$. Hence,
%we obtain the following definition:
%
%\newcommand{\VecD}{\C{VecD}}
%\newcommand{\VecNil}{\etag{\CN{vnil}}}
%\newcommand{\VecCons}[2]{\etag{\CN{vcons}}\:#1\:#2}
%
%\[\stk{
%\VecD : \Set \To \TagIDesc{\Nat} \\
%\begin{array}{@{}ll}
%\VecD\: \V{X} = \\ \quad\bigRedBracket{ 
%            \begin{array}{l}
%                \pair{[]}{\_}{} 
%                \\\\
%                \bigRedBracket{
%                \begin{array}{l} 
%                  \LAM{\V{n}} \caseB{\V{n}}{\NatZero \mapsto [\VecNil] \\
%                                   (\NatSuc{\V{n}}) \mapsto [\VecCons{\!}{\!}]} \\
%                  \LAM{\V{n}} \caseB{\V{n}}{\NatZero \mapsto [\DConst{\Unit}] \\
%                                   (\NatSuc{\V{n}}) \mapsto [\DSigma{\V{X}}{\DVar{\V{n}}}]}
%                \end{array}}
%            \end{array}}
%\end{array}
%}\]
%
%We will see more instances of this pattern in the following.


\subsection{Examples}
\label{sec:idesc-examples}

\paragraph{Natural numbers:}

\begin{wstructure}
<- Nat
    -> [equation]
    <- Non-indexed types lives in IDesc 1
        -> This applies to all previous examples
\end{wstructure}

In order to gain some intuition of $\IDesc{\!}$, let us re-implement
the pattern functor of natural numbers:
%
\[\stk{
\NatD : \IDesc{\Unit} \\
\NatD \mapsto \DSigma{(\EnumT{[ \NatZero\: \NatSuc{\!} ]})}
                     {\red{[} \DConst{\Unit} \quad \DVar{\Void} \red{]}}
}\]

Because $\Nat$ is just an inductive type, $\NatD$ is a $\Unit$-indexed
functor. Therefore, the recursive argument is materialised by
$\DVar{\Void}$, where we were using $\DIndx{\!}$ in the previous
presentation. This transformation generalizes to all inductive
types. Moreover, we gain the ability to write mutually recursive
inductive types.



\paragraph{Indexed descriptions:}

\begin{wstructure}
<- Levitation [figure]
    <- Following Desc encoding
        /> Note: simple datatype
            -> Live in IDesc 1
    -> Behind the scene, relies on the special purpose switchD
\end{wstructure}

Note that $\IDesc{\V{I}}$ itself is merely an inductive type. Hence,
we can describe it in $\IDesc{\Unit}$:
%
\[\stk{
\IDescD : \PI{\V{I}}{\Set} \IDesc{\Unit} \\
\begin{array}{@{}ll}
\IDescD\: \V{I} \mapsto \DSigma{\!}{\!} & (\EnumT \sqr{ 
                                          \DVar{\!}\:
                                          \DConst{\!}\:
                                          \DProd{\!}{\!}\:
                                          \DSigma{\!}{\!}\: 
                                          \DPi{\!}{\!}
                                             }) \\
                              & \bigRedBracket{\begin{array}{l}
                                      \DConst{\V{I}}                  \\
                                      \DConst{\Set}               \\
                                      \DProd{\DVar{\Void}}{\DVar{\Void}}  \\
                                      \DSigma{\Set}{(\LAM{\V{S}} \DPi{\V{S}}{(\LAM{\_} \DVar{\Void})})} \\
                                      \DSigma{\Set}{(\LAM{\V{S}} \DPi{\V{S}}{(\LAM{\_} \DVar{\Void})})}
                                   \end{array}
                             }
\end{array}
}\]

Therefore, this universe is self-describing, hence can be
levitated. As before, we rely on a special purpose $\F{switchID}$
operator to build the finite function space $\bigRedBracket{\ldots}$.

\paragraph{Vectors:}

\newcommand{\VecD}{\F{VecD}}
\newcommand{\VecNil}{\etag{\CN{vnil}}}
\newcommand{\VecCons}[2]{\etag{\CN{vcons}}\:#1\:#2}

So far, the examples we have seen lives in $\IDesc{\Unit}$, hence are
not using any indexing. We remedy this by encoding the vectors. Recall
that the constructors $\VecNil$ and $\VecCons{\!}{\!}$ are only defined for an
index $\NatZero$ and $\NatSuc$ respectively.:
%
\[
\stk{
\data \D{Vec}\: \PITEL{\V{X}}{\Set} : \PI{\V{n}}{\Nat} \Set \where \\
\;\;\begin{array}{@{}l@{\::\:\:}l@{\quad}l}
    \VecNil          & \D{Vec}\:\V{X}\:{\NatZero)}   \\
    \VecCons{\!}{\!} & _{\PI{\V{n}}{\Nat}}\V{X} \To \D{Vec}\:{\V{X}}\:{\V{n}} \To \D{Vec}\:{\V{X}}\:{(\NatSuc{\V{n}})}
\end{array}
}
\]

One way to code constrained datatypes is to appeal to equality. The
constraints are therefore captured by equations in the datatype. In
this case, we obtain the following definition:
%
\[\stk{
\VecD : \Set \To \Nat \To \IDesc{\Nat} \\
\begin{array}{@{}ll}
\VecD\: \V{X}\: \V{n} = \DSigma{\!}{\!} \!\!\!\!& (\EnumT{\sqr{ \VecNil\:\VecCons{\!}{\!} }}) \\
                        & \bigRedBracket{
                          \begin{array}{l}
                            \DConst{(\V{n} \PropEq \NatZero)} \\
                            \DSigma{\Nat}{\LAM{\V{m}} \stk{\DProd{\DVar{\V{m}}}{\\\DConst{(\V{n} \PropEq \NatSuc{\V{m}})}}}}
                          \end{array}
                          }
\end{array}
}\]

In the $\VecNil$ case, a proof must be provided that the index is
equal to $\NatZero$. In the $\VecCons{\!}{\!}$ case, we first store an element
$\V{m}$ of $\Nat$. However, the constraint stipulates that $\V{m}$
cannot be \emph{any} natural numbers: it must be ``the index minus
one''. This translates into the constraint $\V{n} \PropEq
\NatSuc{\V{m}}$.

However, one could, quite rightfully, be worried by the introduction
of equalities in the picture. In a programming context, equalities
haunt us, begging for proofs. As much as possible, one would like to
avoid suffering from this burden. However, the equalities introduced
here are rather special: they are \emph{equations} constraining
variables to certain terms. \citet{goguen:pattern-matching} have
shown, in the context of dependent pattern matching, how to tame these
equations.

\begin{wstructure}
!!! Need Help !!!
<- Brady optimisation: forcing
    <- Source to source translation
    <- Able to remove some constraints
    -> Example: Fin [figure]
    ??? More technical detail needed
\end{wstructure}

Further, we can actually remove these equations altogether. Let us
look back at $\D{Vec}$. We note that the equations are introduced
because we are \emph{storing} the index of the inductive family.
However, \emph{inductive families need not store their
  indices}~\cite{brady:index-inductive-families}.  By examining the
incoming index, we can apply the \emph{forcing} and \emph{de-tagging}
optimisations to our initial definition of $\D{Vec}$. This gives the
following, equivalent definition:
%
\[\stk{
\VecD \:\PITEL{\V{X}}{\Set} : \Nat \To \IDesc{\Nat} \\
\begin{array}{@{}lll}
\VecD\:\V{X}\: \NatZero     & = & \DConst{\Unit} \\
\VecD\:\V{X}\: (\NatSuc{\V{n}}) & = & \DProd{\DConst{\V{X}}}{\DVar{\V{n}}}
\end{array}
                                       
}\]
%
The equations (and constructors) have simply disappeared. A similar
example is $\Fin{\!}$, specified by:
%
\[
\stk{
\data \Fin{\!} : \PI{\V{n}}{\Nat} \Set \where \\
\;\;\begin{array}{@{}l@{\::\:\:}l@{\quad}l}
    \FinZero      & _{\PI{\V{n}}{\Nat}}\Fin{(\NatSuc{\V{n}})}   \\
    \FinSuc{\!}   & _{\PI{\V{n}}{\Nat}}\Fin{\V{n}} \To \Fin{(\NatSuc{\V{n}})}
\end{array}
}\]
%
In this case, we can apply forcing, but not detagging, since both
$\FinZero$ and $\FinSuc{\!}$ both target $\NatSuc{\!}$:
%
\[\stk{
\FinD : \Nat \To \IDesc{\Nat} \\
\begin{array}{@{}llll}
\FinD\: \NatZero     & = & \multicolumn{2}{l}{\DSigma{(\EnumT{\Void})}{\Void} } \\
\FinD\: (\NatSuc{\V{n}}) & = & \DSigma{\!}{\!}\!\!\!\!\! & (\EnumT{\sqr{ \FinZero \: \FinSuc{\!} }}) \\
                     &   &             & \bigRedBracket{
                                         \begin{array}{l}
                                         \DConst{\Unit} \\
                                         \DVar{\V{n}}
                                         \end{array}
                                         }
\end{array}
}\]

We should precise that forcing a description is not guaranteed to
remove all constraints. It is subject to future work to see if
constraints can be entirely eradicated, or presented more conveniently
to the developer.  Finally, it is worth mentioning that these
optimisations are \emph{source-to-source} transformations on
descriptions.

\paragraph{Tagged indexed descriptions:}

When defining an indexed datatype, we have access to its
index. Therefore, we can use this index to influence the choice of
constructors. This captures the essence of dependent datatypes: a
term -- the index -- has the ability to influence the datatype. We
define tagged indexed descriptions to capture this specificity.

We divide a tagged indexed description in two parts: first, the
constructors that do not depend on the index; then, the constructors
that do. The non-dependent part mirrors the definition for non-indexed
descriptions. The index-depend part simply indexes the choice of
constructors by $\V{I}$. Hence, by inspecting the index, it is
possible to enable or disable constructors.
%
\[
\begin{array}{@{}l@{\:\mapsto\:\:}l}
 \TagIDesc{\V{I}}  & \TIMES{\ATagIDesc{\V{I}}}{\ITagIDesc{\V{I}}} \\
 \ATagIDesc{\V{I}} & \SIGMA{\V{E}}{\EnumU} (\PI{\V{i}}{\V{I}} \spi{\V{E}}{(\LAM{\_} \IDesc{\V{I}})}) \\
 \ITagIDesc{\V{I}} & 
     \SIGMA{\V{F}}{\V{I} \To \EnumU} (\PI{\V{i}}{\V{I}} \spi{(\V{F}\: \V{i})}{(\LAM{\_} \IDesc{\V{I}})}) 
\end{array}
\]

\begin{wstructure}
<- Vectors
    Do we treat them in the end? 
    What can we say here we haven't with Fin?
\end{wstructure}

In the case of a tagged $\D{Vec}$, for instance, for the index
$\NatZero$, we would only propose the constructor
$\ListNil$. Similarly, for $\NatSuc{n}$, we would only propose the
constructor $\ListCons{\!}{\!}$.
 
\paragraph{Typed expressions:}

\begin{wstructure}
<- Hutton's razor
    <- Types
        <- 'Nat
        <- 'Bool
    <- Term [figure]
        <- val : Val 'a -> 'a  for Val : Ty -> Set, mapping to Nat and Bool
        <- cond : 'Bool -> a -> a -> a
        <- plus : 'Nat -> 'Nat -> 'Nat
        <- le : 'Nat -> 'Nat -> 'Bool
\end{wstructure}

%% Types
\newcommand{\Ty}{\C{Ty}}
\newcommand{\Ebool}{\etag{\CN{bool}}}
\newcommand{\Enat}{\etag{\CN{nat}}}

%% Constructors
\newcommand{\Eval}[1]{\etag{\CN{val}}\:#1}
\newcommand{\Econd}[3]{\etag{\CN{cond}}\:#1\:#2\:#3}
\newcommand{\Eplus}[2]{\etag{\CN{plus}}\:#1\:#2}
\newcommand{\Ele}[2]{\etag{\CN{le}}\:#1\:#2}

%% Index mapper (terminology?)
\newcommand{\Val}[1]{\F{Val}\:#1}
\newcommand{\Var}[2]{\F{Var}_{#1} #2}

%% Hutton expressions
\newcommand{\HExprD}{\C{ExprD}}
\newcommand{\HExprAD}{\C{ExprAD}}
\newcommand{\HExprID}{\C{ExprID}}
\newcommand{\HExprVarD}[1]{\C{ExprD}_{\F{Var},#1}}
\newcommand{\HExprFreeD}{\C{ExprD}^{\C{Free}}}
\newcommand{\HExprAFreeD}{\C{ExprAD}^{\C{Free}}}

We are going to define a syntax for a small typed language. We
consider two types, natural numbers and booleans:
%
\[
\Ty \mapsto \EnumT{\sqr{\Enat\: \Ebool}}
\]

An expression of this language is either a value, a conditional
expression, an addition of numbers, or a comparison of
numbers. Informally, their type is the following:
%
\[
\begin{array}{l@{\::\:\:}l}
\Econd{\!}{\!}{\!}   & \forall \Bhab{\V{ty}}{\Ty} . \Ebool \To \V{ty} \To \V{ty} \To \V{ty}  \\ 
\Eplus{\!}{\!}       & \Enat \To \Enat \To \Enat                           \\
\Ele{\!}{\!}         & \Enat \To \Enat \To \Ebool                          \\
\Eval{\!}            & \forall \Bhab{\V{ty}}{\Ty} . \Val{\V{ty}} \To \V{ty}
\end{array}
\]
%
The function $\Val{\!}$, used in the definition of $\Eval{\!}$, simply
maps a type $ty$ of the object language to the corresponding type in
the host language. Hence, the arguments of $\Eval{\!}$ are ensured to
be of the expected type. We assume that $\Nat$ and $\Bool$ represent
natural numbers and booleans in the host language, equipped with an
addition operation $\F{plusHost}$ and a comparison function
$\F{leHost}$. We define $\Val{\!}$ as follows:
%
\[\stk{
\Val{\!} : \Ty \To \Set \\
\begin{array}{@{}l@{\:=\:\:}l}
\Val{\Enat}   & \Nat \\
\Val{\Ebool}  & \Bool
\end{array}
}\]

In our universe of descriptions, the syntax of this language is
described by a tagged indexed description. We use the index to carry
the type: the resulting description is indexed by $\Ty$. We observe
that some constructors are always defined, namely $\Econd{\!}{\!}{\!}$
and $\Eval{\!}$. On the other hand, the $\Eplus{\!}{\!}$ and
$\Ele{\!}{\!}$ constructors are index-dependent. $\Eplus{\!}{\!}$ is
defined if and only if the result type -- the index -- is $\Enat$,
whereas $\Ele{\!}{\!}$ is defined if and only if the index is
$\Ebool$. The actual code precisely follows this intuition, as shown
in Figure~\ref{fig:hexpr-full}. For brevity, we use an informal
$\case{\ldots}{\ldots}$ notation, simulating a definition by
pattern-matching. Formally, this corresponds to a call to the
$\switch{\!}{\!}{\!}{\!}$ eliminator.

\begin{figure}

\[\stk{
\stk{
\HExprD : \TagIDesc{\Ty} \\
\HExprD \mapsto ( \HExprAD , \HExprID ) \\
} \\
\\
\stk{
\HExprAD : \ATagIDesc{\Ty} \\
\HExprAD \mapsto \bigRedBracket{
                 \begin{array}{l}
                   {\sqr{\Eval{\!}\: \Econd{\!}{\!}{\!}\!\,}} \red{,} \\
                   \LAM{\V{ty}}
                   \bigRedBracket{
                   \begin{array}{l}
                   \DConst{(\Val{\V{ty}})} \\
                   \DProd{\DVar{\Ebool}}{\DProd{\DVar{\V{ty}}}{\DVar{\V{ty}}}}
                   \end{array}
                   }
                 \end{array}
                 }
\\
\\
} 
\\
\stk{
\HExprID : \ITagIDesc{\Ty} \\
\HExprID \mapsto \bigRedBracket{
                 \begin{array}{l}
                   \LAM{\V{ty}} \case{\V{ty}}{\Enat \To {\sqr{\Eplus{\!}{\!}\!\,}} \\ \Ebool \To {\sqr{\Ele{\!}{\!}\!\,}}} \red{,} \\
                   \LAM{\_} \DProd{\DVar{\Enat}}{\DVar{\Enat}} 
                   \end{array}
                   }
}
}\]

\caption{Syntax of typed expressions}
\label{fig:hexpr-full}

\end{figure}

\begin{wstructure}
    -> evaluation: IMu TermD -> Val
        -> it is a catamorphism
            <- Look closer at the type
        -> implementation [code]
            <- Just define one reduction step
            -> cata does the rest
                /> cata is for free!
\end{wstructure}

\newcommand{\evalH}{\F{eval}_{\green{\Downarrow}}}
\newcommand{\evalOne}{\F{eval}_{\green{\downarrow}}}

Having implemented the syntax, we would like to describe its
semantics. To do so, we implement an evaluator. The type of the
evaluator is:
%
\[
\evalH : \PI{\V{ty}}{\Ty} 
         \IMu{\Ty}{\toIDesc{\HExprD}}{\V{ty}} \To
         \Val{\V{ty}}
\]
%
Where we overload the notation $\toIDesc{\V{TID}}$ to denote the
indexed description computed from the tagged indexed description
$\V{TID}$. The type of $\evalH$ is strikingly similar to a
catamorphism. Indeed, implementing a single step of evaluation -- the
algebra -- is sufficient, as $\cataI$ gives, for free, the full
evaluator. The implementation is as follows:
%
\[\stk{
\evalOne : \PI{\V{ty}}{\Ty} \idescop{\toIDesc{\HExprD}\:\V{ty}}{\Ty}{\Val{\!}}
           \To {\Val{\V{ty}}} \\
\begin{array}{@{}l@{}c@{}l@{\:=\:\:}l}
\evalOne\: & \_\: & \pair{\Eval{\!}}{\V{x}}{}                                             & \V{x} \\
\evalOne\: & \_\: & \pair{\Econd{\!}{\!}{\!}}{\pair{\BoolTrue}{\pair{\V{x}}{\_}{}}{}}{}   & \V{x} \\
\evalOne\: & \_\: & \pair{\Econd{\!}{\!}{\!}}{\pair{\BoolFalse}{\pair{\_}{\V{y}}{}}{}}{}  & \V{y} \\
\evalOne\: & \Enat\: & \pair{\Eplus{\!}{\!}}{\pair{\V{x}}{\V{y}}{}}{}                     & \F{plusHost}\: \V{x}\: \V{y} \\
\evalOne\: & \Ebool\: & \pair{\Ele{\!}{\!}}{\pair{\V{x}}{\V{y}}{}}{}                      & \F{leHost}\: \V{x}\: \V{y} 
\end{array} \\
\\
\evalH : \PI{\V{ty}}{\Ty} 
           \IMu{\Ty}{\toIDesc{\HExprD}}{\V{ty}} \To
           \Val{\V{ty}} \\
\evalH\: \V{ty}\: \V{term} = \cataI_{\Ty}
                                 \toIDesc{\HExprD}\: 
                                 \Val{\!}\: 
                                 \evalOne\: 
                                 \V{ty}\: 
                                 \V{term}
}\]

\begin{wstructure}
    /> Closed term
        <- only constants and operations on them
        -> Extend Val with Var : Ty -> Set, mapping to EnumU
            -> Open term
            -> Language of well-typed terms
                <- By construction
\end{wstructure}

Hence, we have defined the syntax of a typed language of arithmetic
and boolean expressions. We have given its semantics through an
evaluation function. Provided a one step semantic of the language, the
big step interpreter is granted without effort thanks to the generic
catamorphism.

However, so far, we are only able to define and manipulate
\emph{closed} terms. By abstracting over $\Val{\!}$, it is possible to
build and manipulate \emph{open} terms, that is, terms with
variables. Following $\Val{\!}$, we define $\Var{}{}$ by:
%
\[\stk{
\Var{}{} : \EnumU \To \Ty \To \Set \\
\Var{\V{dom}}{\_} = \EnumT{\V{dom}}
}\]
%
Whereas $\Val{\!}$ was mapping the type to the corresponding host type,
$\Var{}{}$ maps types to a finite set. The finite set -- the context
-- contains closed terms. A variable is therefore a $\Eval{\!}$ that
contains a pointer to a particular element of the finite set -- an
element of $\EnumT{\V{dom}}$. 

Consequently, replacing $\Val{\V{ty}}$ by
$(\SUM{\Val{\V{ty}}}{\Var{\V{dom}}{\V{ty}}})$ in
Figure~\ref{fig:hexpr-full} turns the language of closed terms into a
language of opened terms with variables and constants. For
readability, we abbreviate $\LAM{\V{ty}}
\SUM{\Val{\V{ty}}}{\Var{\V{dom}}{\V{ty}}}$ by
$\SUM{\Val{\!}}{\Var{\V{dom}}{}}$. \note{Is it polite and
  comprehensible to ask that?} This defines a new indexed description,
called $\HExprVarD{\V{dom}}$.

\begin{wstructure}
        <- evaluator, with a context
            -> First, close variables
                -> Perform assignment
                <- subst [code]
\end{wstructure}

\newcommand{\discharge}{\F{discharge}}

Again, we would like to give a semantics to this extended language. We
proceed in two steps: first, we replace the variables by their value
in the context; then, we evaluate the resulting closed term. Thanks to
$\evalH$, the second problem is already solved. Let us focus on
discharging variables from the context. Again, we can subdivide this
problem: first, discharging a single variable from the context; then,
applying this $\discharge$ function on every variables in the term.

The $\discharge$ function is relative to the required type and a
context of the right type. Its action is to map values to themself,
and variables to their value in context. This corresponds to the
following function:
%
\[\stk{
\begin{array}{@{}ll}
\discharge : & \PITEL{\V{ty}}{\Ty}
               \PITEL{\V{dom}}{\EnumU} \\
             & \PI{\V{\gamma}}{\spi{\V{dom}}{(\LAM{\_} \IMu{\Ty}{\toIDesc{\HExprVarD{\V{dom}}}}{\V{ty}})}} \\
             & (\SUM{\Val{\V{ty}}}{\Var{\V{dom}}{\V{ty}}}) \To
               \IMu{\Ty}{\toIDesc{\HExprVarD{\V{dom}}}}{\V{ty}} 
\end{array} \\
\begin{array}{@{}l@{\:\mapsto\:\:}l}
\discharge\: \V{ty}\: \V{dom}\: \V{\gamma}\: (\SumLeft \V{x})  & \Con{\pair{\Eval{\!}}{\V{x}}{}} \\
\discharge\: \V{ty}\: \V{dom}\: \V{\gamma}\: (\SumRight \V{v}) &
\end{array}\\
\qquad\switch{\V{dom}}{(\LAM{\_}
\IMu{\Ty}{\toIDesc{\HExprVarD{\V{dom}}}}{\V{ty}})}{\V{\gamma}}{\V{v}}
}\]

\begin{wstructure}
            /> Then, perform subst everywhere in the term
                -> Show type [code]
                /> This is a bind!?
                -> There is some more structure 
                    -> We should try to get it
\end{wstructure}

\newcommand{\substH}{\F{substExpr}}
\newcommand{\domNat}{dom_{\CN{nat}}}
\newcommand{\domBool}{dom_{\CN{bool}}}
\newcommand{\gammaNat}{\V{\ensuremath{\gamma_{\CN{nat}}}}}
\newcommand{\gammaBool}{\V{\ensuremath{\gamma_{\CN{bool}}}}}
\newcommand{\GammaSpi}[2]{\F{\ensuremath{\Gamma_{\CN{ty}}}}\: #1\: #2}


We are now left with applying $\discharge$ over all variables of the
term. The type of this operation is the following:
%
\[
\begin{array}{@{}ll}
\substH  : & \PITEL{\V{dom}}{\EnumU} \\
           & \PITEL{\V{\gammaNat}}{\GammaSpi{\V{dom}}{\Enat}} 
             \PITEL{\V{\gammaBool}}{\GammaSpi{\V{dom}}{\Ebool}} \\
           & \begin{array}{@{}ll}
             \PI{\V{\sigma}}{& \PITEL{\V{dom}}{\EnumU} \\
                             & \PITEL{\V{\gammaNat}}
                                     {\GammaSpi{\V{dom}}{\Enat}} \\
                             & \PITEL{\V{\gammaBool}}
                                     {\GammaSpi{\V{dom}}{\Ebool}} \\
                             & \PI{\V{ty}}{\Ty} (\SUM{\Val{\V{ty}}}{\Var{\V{dom}}{\V{ty}}}) \To \\
                             & \IMu{\Ty}{\toIDesc{\HExprD}}{\V{ty}}}
             \end{array}\\
          & \PI{\V{ty}}{\Ty}
            \IMu{\Ty}{\toIDesc{\HExprVarD{\V{dom}}}}{\V{ty}} \To \\
          & \IMu{\Ty}{\toIDesc{\HExprD}}{\V{ty}}
\end{array}
\]
%
Where $\GammaSpi{\!}{\!}$ corresponds to a context, defined by:
%
\[\stk{
\GammaSpi{\!}{\!} : \EnumU \To \Ty \To \Set                                             \\
\GammaSpi{\V{dom}}{\V{ty}} = \spi{\V{dom}}{(\LAM{\_} \IMu{\Ty}{\toIDesc{\HExprVarD{\V{dom}}}}{\V{ty}})} 
}\]


Abstracting away the book-keeping introduced by contexts, this
definition looks familiar. It is similar to a monadic \bind. This is
not surprising as we are defining a first-order syntax with variables:
our datatype enjoys more structure than what we are given. We are
facing a free monad, where $\Eval{\!}$ is the \return\ introducing
variables. For convenience, we wrap $\discharge$ in a $\V{\sigma}$
function that picks the context of the right type:
%
\[
\F{$\sigma$}\: \V{dom}\: \gammaNat\: \gammaBool\: \V{ty}\: \V{var} \mapsto
    \F{$\discharge$}\: \V{ty}\: \V{dom}\: \F{$\gamma$}_{\V{ty}}\: \V{var} 
\]
%
Where $\F{$\gamma$}_{\V{ty}}$ is short for
 $\caseB{\V{ty}}{\Enat  \To \gammaNat \\
                 \Ebool \To \gammaBool}$

Instead of implementing $\substH$ in this special case, we are now
going to implement the \emph{free indexed-monad construction}.

\subsection{Free indexed monad}

\begin{wstructure}
<- Variation on a theme: free imonad construction
    <- Recall existence of generic free monad construction
    -> Present its generalisation to IDesc [equation]
        <- \I -> IDesc I as describing an indexed endofunctor
        <- Free monad construction
    -> Still a suitable, generic notion of substitution
        <- show type signature
        <- show implementation?? (space! space!)
\end{wstructure}

In Section~\ref{sec:desc-free-monad}, we have built a free monad
operation for simple descriptions. The process is similar in the
indexed world. Namely, given an indexed functor, we derive the indexed
functor coding its free monad: \note{pwm: Whoa there. Maybe we should
  say something about IMonads in general before we get to this point?}
%
\[\stk{
\begin{array}{ll}
\FreeIMonad{\_}{} : & _{\PI{\V{I}}{\Set}}
                     \PITEL{\V{R}}{\TagIDesc{\V{I}}} 
                     \PITEL{\V{X}}{\V{I} \To \Set}\To 
                      \TagIDesc{\V{I}}
\end{array} \\
\FreeIMonad{\pair{\V{E}}{\V{F}}{}}{\V{I}}{\V{R}} \mapsto \\ \;\;
    \pair{\pair{\ListCons{\DVar{\!}}{(\fst{\V{E}})}} 
               {\LAM{\V{i}}
                \pair{\DConst{(\V{R}\: \V{i})}}
                     {(\snd{\V{E}})\: \V{i}}{}}{}}
         {\V{F}}{}
}\]


\newcommand{\substI}{\F{substI}}


Just as in the universe of descriptions, this construction comes with
an obvious \return\ and a substitution operation, the \bind. Its
definition is the following:
%
\[\stk{
\begin{array}{@{}ll}
\substI : & _{\PI{\V{I}}{\Set}}
            \PITEL{\V{R}}{\TagIDesc{\V{I}}}
            \PI{\V{X}, \V{Y}}{\V{I} \To \Set} \\
          & (\PI{\V{i}}{\V{I}} \V{X}\:\V{i} \To 
                               \IMu{\V{I}}{(\toIDesc{\FreeIMonad{\V{R}}{\V{I}}{\V{Y}}})}{\V{i}}) \To \\
          & \PITEL{\V{i}}{\V{I}}
            \PITEL{\V{D}}{\IMu{\V{I}}{(\toIDesc{\FreeIMonad{\V{R}}{\V{I}}{\V{X}}})}{\V{i}}} \To
            \IMu{\V{I}}{(\toIDesc{\FreeIMonad{\V{R}}{\V{I}}{\V{Y}}})}{\V{i}}
\end{array} \\
\substI\: \V{X}\: \V{Y}\: \V{R}\: \V{\sigma}\: \V{i}\: \V{t} = \\
\qquad    \cataI\: \toIDesc{\FreeIMonad{\V{R}}{}{\V{X}}}\:
                      (\IMu{}{\toIDesc{\FreeIMonad{\V{R}}{}{\V{Y}}}})\:
                      (\F{applyI}\: \V{R}\: \V{X}\: \V{Y}\: \V{\sigma})\:
                      \V{i}\:
                      \V{t} 
}\]
% 
Where  $\F{applyI}$ is defined as follow:
%
\[\stk{
\begin{array}{@{}ll}
\F{applyI} : & _{\PI{\V{I}}{\Set}}
            \PITEL{\V{R}}{\TagIDesc{\V{I}}}
            \PI{\V{X}, \V{Y}}{\V{I} \To \Set} \\
          & (\PI{\V{i}}{\V{I}} \V{X}\: \V{i} \To \IMu{\V{I}}{\toIDesc{(\FreeIMonad{\V{R}}{\V{I}}{\V{Y}})}}{\V{i}}) \To \\
          & \PI{\V{i}}{\V{I}} 
            \idescop{\toIDesc{(\FreeIMonad{\V{R}}
                                         {\V{I}}
                                         {\V{X}})}\: 
                     \V{i}}
                    {\V{I}}
                    {\IMu{\V{I}}{\toIDesc{(\FreeIMonad{\V{R}}{\V{I}}{\V{Y}})}}} \To 
           \IMu{\V{I}}{\toIDesc{(\FreeIMonad{\V{R}}{\V{I}}{\V{Y}})}}{\V{i}}
\end{array} \\
\begin{array}{@{}l@{\:\mapsto\:\:}l}
\F{applyI}\: \V{R}\: \V{X}\: \V{Y}\: \V{\sigma}\: \V{i}\: \pair{\DVar{\!}}{\V{x}}{}   & \V{\sigma}\: \V{i}\: \V{x}                   \\
\F{applyI}\: \V{R}\: \V{X}\: \V{Y}\: \V{\sigma}\: \V{i}\: \pair{\etag{t}\,}{\V{ys}}{} & \Con{\pair{\etag{t}}{\V{ys}}{}}
\end{array}
}\]
 
Let us now consider two examples of free indexed monad.


\paragraph{Typed expressions:}

\begin{wstructure}
<- Hutton's razor is a free monad
    <- substI was our candidate bind
        -> Massage the definition of expr to get it for free
    <- Finding the functor
        <- 'val is the return
        <- The other components are the action
        -> Updated tagged description [figure]
    -> Compute the free monad Hutton * X
        -> With X = Val: We get back our closed terms
        -> With X = Val + Var vars: We get back our open terms
\end{wstructure}

In Section~\ref{sec:idesc-examples}, we had the intuition that our
datatypes $\HExprD$ and $\HExprVarD{\V{dom}}$ enjoy a monadic
structure. We had identified the variable substitution operation as
the \bind\ of a free monad. To exhibit its monadic structure, we first
have to massage the definition of our datatype.

As previously mentioned, we identify $\Eval{\!}$ with the \return\ of
the free monad, while the other components are the action of the
monad. As a result, the definition is similar to $\HExprD$ presented
in Figure~\ref{fig:hexpr-full}, replacing $\HExprAD$ by
$\HExprAFreeD$:
%
\[\stk{
\HExprAFreeD : \ATagIDesc{\Ty} \\
\HExprAFreeD \mapsto \bigRedBracket{
                 \begin{array}{l}
                   \EnumT{\sqr{\Econd{\!}{\!}{\!}}} \red{,} \\
                   \LAM{\V{ty}}
                   \bigRedBracket{
                   \begin{array}{l}
                   \DProd{\DVar{\Ebool}}{\DProd{\DVar{\V{ty}}}{\DVar{\V{ty}}}}
                   \end{array}
                   }
                 \end{array}
                 }
}\]

We call this datatype $\HExprFreeD$. By a simple unfolding of
definition, we note that $\FreeIMonad{\HExprFreeD}{\Ty}{\Val{\!}}$
corresponds to the syntax of closed terms, $\HExprD$. Similarly,
$\FreeIMonad{\HExprFreeD}{\Ty}{(\SUM{\Val{\!}}{\Var{\V{dom}}{}})}$
corresponds to expressions with variables, $\HExprVarD{\V{dom}}$.

\begin{wstructure}
    /> On open terms, we get a substitution
        -> Apply substI on assgnmt
            -> Have a well-typed language
            -> Get a safe evaluator 
                <- for well-typed terms 
                <- in well-typed contexts
\end{wstructure}

The evaluator for closed terms we implemented in
Section~\ref{sec:idesc-examples} remains unchanged. It reduces closed
terms in $\FreeIMonad{\HExprFreeD}{\Ty}{\Val{\!}}\: \V{ty}$ to values in
$\Val{\V{ty}}$. We are left with implementing $\substH$. We simply
have to fill in the right arguments to $\substI$, the type guiding us:
%
\[\stk{
\substH\: \V{dom}\:
          \gammaNat\: \gammaBool\:
          \V{\sigma}\: 
          \V{ty}\: 
          \V{term} \mapsto  \\
\;\;\ \begin{array}{ll}
       \substI_{\Ty}\: &  \HExprFreeD\: 
                         (\SUM{\Val{\!}}{\Var{\V{dom}}{}})\: 
                         \Val{\!} \\
                      &
                        (\V{\sigma}\: \V{dom}\: \gammaNat\: \gammaBool)\:
                        \V{ty}\:
                        \V{term}
      \end{array}
}\]
%
Hence completing our implementation of the open terms interpreter. 

We have defined a well-typed language of arithmetical expressions,
taking advantage of indexing. Then, we have implemented an evaluator
for closed term, based on the generic catamorphism function. Using the
free monad construction, we have automatically derived the language of
open terms. Using its monadic structure, we have implemented the
interpreter for open terms in context. Hence, without much efforts, we
have described the syntax of a well-typed language, together with its
semantics.

\begin{wstructure}
<- IDesc
    <- Another instance of free monad
        <- Var: Return
        <- Remaining: (not even indexed) functor
    -> Madness just starts
        <- map operation
        <- [ subst sigma D ] X = [D] (\x -> [subst sigma x] X)
        ???
\end{wstructure}

\paragraph{Indexed descriptions:}

Another instance of free monad is $\IDesc{\!}$ itself. Indeed,
$\DVar{\!}$ is nothing but the \return. The remaining constructors are
the carrier functor, trivially indexed by $\Unit$. The carrier functor
is described as follow:
%
\[\stk{
\IDescFreeD : \ATagIDesc{\Unit} \\
\begin{array}{@{}ll}
\IDescFreeD \mapsto \bigRedBracket{\begin{array}{l}
                                \sqr{\DConst{\!}\:
                                 \DProd{\!}{\!}\:
                                 \DSigma{\!}{\!}\: 
                                 \DPi{\!}{\!}} \red{,}\\
                                  \LAM{\_}\bigRedBracket{\begin{array}{l}
                                        \DConst{\Set}               \\
                                        \DProd{\DVar{\Void}}{\DVar{\Void}}  \\
                                        \DSigma{\Set}{(\LAM{\V{S}} \DPi{\V{S}}{(\LAM{\_} \DVar{\Void})})} \\
                                        \DSigma{\Set}{(\LAM{\V{S}} \DPi{\V{S}}{(\LAM{\_} \DVar{\Void})})}
                                    \end{array}}\end{array}}
\end{array}
}\]
%
Then, we get $\IDesc$ by building its free monad:
%
\[\stk{
\IDescD : \PI{\V{I}}{\Set} \TagIDesc{\Unit} \\
\IDescD\: \V{I} \mapsto \FreeIMonad{\red{[}\IDescFreeD\red{,[}\LAM{\_}\sqr{}\red{,}\LAM{\_}\red{[]]]}}{\Unit}\LAM{\_}\V{I}
}\]


In this section, we have presented the universe of indexed
description. It embraces indexed families of types and, as such,
allows us to write dependent datatypes. Hence, we have presented
several example of indexed datatypes. In this context, we have
presented the free monad construction, together its monadic
operations.
