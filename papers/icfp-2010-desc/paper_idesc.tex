\section{Indexing descriptions}
\label{sec:indexing-desc}

\begin{wstructure}
!!! Need Help !!!
<- Motivation
    <- Desc: expressivity of simply-typed data-types: inductive types
        <- Values do not influence types
    /> Example: Vectors
        <- Cannot be defined by just induction
            <- Vectors of all size need to be defined at the *same* time
            -> Defined as a *family* of types
                -> Index
        -> I -> IDesc I: Inductive family
    ???
\end{wstructure}

\note{ Need care: motivating motivation of indexing. }

So far, we have explored the well-known realm of inductive types. We
have built upon the experience gained in using simply-typed languages,
such as Haskell or OCaml. In our dependent setting, we provided these
data-types by the mean of $\Desc$, a universe of descriptions. 

While inductive types are the alpha and omega of simply-typed
languages, evolving in a dependent setting fosters new
opportunities. The typical example is bounded lists, also known as
vectors. A vector is a list decorated by its length. Having this
information prevents hazardous operations, such as taking the head of
an empty vector: the head function only takes vectors of length
$\NatSuc{\V{n}}$, as enforced by its type. This is made possible by the
very specificity of dependently-typed systems: terms -- the length --
are allowed to influence types -- the vector type. \note{Reference
  paper to cite about vectors in dependent types?}

However, this new class of objects cannot be defined by mere
induction. In the case of vectors, for instance, we have to define the
whole \emph{family} of vector in one go: vectors of all size needs to
be defined at the same time. Where simply-typed languages have
inductive types, in dependently typed programming we the basic grammar of
data-types should be that of inductive families of types. To this end, we
rely on \emph{indexing}. We are going to transform the $\Desc$ universe into
$\IDesc{\!}$, the universe of indexed descriptions. We express inductive families
by the $\V{I} \To \IDesc{\V{I}}$ type.  \note{pwm: Vec might not be the best
motivating example here, since it doesn't appear in the paper (more on that
later). Come to think of it, this is entirely too vague without spelling out
a concrete example.} 

\subsection{Desc, atomically}
\label{sec:idesc-atomic-desc}

\begin{wstructure}
[Outdated: type former presentation instead]
<- Adding hindx have introduced some duplication
    <- indx == hindx 1
    -> We can factor out commonalities 
        /> Obtain an equivalent presentation
        /> Still embeddable (refer to the Agda model)
\end{wstructure}

\begin{wstructure}
<- Also replacing '1 by 'const  [figure]
    <- For convenience
        <- 'const X equivalent to 'sigma X (\_ -> '1)
        /> Easier to abstract
            <- Extensionally same
            /> 'const more useful in practice
\end{wstructure}


Before moving on indexed descriptions, we have to carry out some
maintenance work on descriptions. We presented $\Desc$ as the grammar
of inductive types. Hence, the codes closely follow this grammar. In
the following, we adopt an alternative presentation. With
$\DSigma{\!}{\!}$, we are actually \emph{quoting} a standard
type-former, namely

$$\Bhab{\Sigma}{\PI{\V{S}}{\Set} \PI{\V{S}}{\Set} \Set}$$

In the alternative presentation, we go further and present all our
codes as quotations of standard type-formers. This presentation is
shown in Figure~\ref{fig:type-former-desc}. The reader will notice
that we replace $\DUnit$ by a more general $\DConst{\!}$ code. Whereas
$\DUnit$ was interpreted as the unit set, $\DConst{\V{X}}$ is
interpreted as $\V{X}$, for any $\Bhab{\V{X}}{\Set}$. Extensionally,
$\DConst{\V{X}}$ and $\DSigma{\V{X}}{\DUnit}$ are equivalent. However,
$\DConst{\!}$ is more succinct. More importantly, $\DConst$ is
\emph{first-order}, unlike its equivalent encoding. From a
definitional perspective, we are giving more opportunities to the
type-system, hence reducing the burden on the programmer. For the same
reason, we introduce $\DProd{\!}{\!}$ that overlaps with
$\DSigma{\!}{\!}$.

This reorganisation is strictly equivalent to the previous one
(Fig.~\ref{fig:hindx_desc}). Just as the previous version, it is also
self-descriptive. We refer the reader to the companion technical
report for details. In this finer-grained presentation, we can define
$\DIndx{\!}$ and $\DHindx{\!}{\!}$ as follow:

\[\begin{array}{l@{\:\mapsto\:\:}l}
\DIndx{\V{D}}         & \DProd{\DId}{\V{D}}                      \\
\DHindx{\V{H}}{\V{D}}     & \DProd{(\DPi{\V{H}}{(\LAM{\_} \DId)})}{\V{D}}
\end{array}
\]

Consequently, the examples previously developed can be
straightforwardly translated into this new presentation. For example,
here is the new definition of $\NatD$:

\[\stk{
\NatD : \Desc \\
\NatD \mapsto \DSigma{(\EnumT{[ \NatZero, \NatSuc{\!} ]})}
                     {[ \DUnit \quad \DId ]}
}\]


In the following, we adopt this last version as our de
facto universe of inductive types. In particular, we are going to
evolve this presentation into an indexed one.

\note{Shall we talk about the Type Theory being Desc Zero? or such story?}

\begin{figure}

\[\stk{
\begin{array}{ll}
\stk{
\data \Desc : \Set \where                                      \\
\;\;\begin{array}{@{}l@{\::\:\:}l@{\quad}l}
    \DId            & \Desc                                    \\
    \DConst{\!}     & \Set \To \Desc                           \\
    \DProd{\!}{\!}  & \PI{\V{D}, \V{D'}}{\Desc} \Desc          \\
    \DSigma{\!}{\!} & \PI{\V{S}}{\Set} \PIS{\V{S} \To \Desc} \Desc \\
    \DPi{\!}{\!}    & \PI{\V{S}}{\Set} \PIS{\V{S} \To \Desc} \Desc 
\end{array}
}
\vspace{0.2in}
\\
\stk{
\descop{\_\:}{} : \Desc \To \Set \To \Set \\
\begin{array}{@{}l@{\:=\:\:}ll}
\descop{\DId}{\V{X}}          &  \V{X}                                           \\
\descop{\DConst{\V{Z}}}{\V{X}}    &  \V{Z}                                           \\
\descop{\DProd{\V{D}}{\V{D'}}}{\V{X}} &  \TIMES{\descop{\V{D}}{\V{X}}}{\descop{\V{D}\V{'}}{\V{X}}}       \\
\descop{\DSigma{\V{S}}{\V{D}}}{\V{X}} &  \SIGMA{\V{s}}{\V{S}} \descop{\V{D}\: \V{s}}{\V{X}}          \\
\descop{\DPi{\V{S}}{\V{D}}}{\V{X}}    &  \PI{\V{s}}{\V{S}} \descop{\V{D}\: \V{s}}{\V{X}}            
\end{array}
}
\end{array}
}\]

\caption{Universe of descriptions based on Type-formers}
\label{fig:type-former-desc}

\end{figure}

\subsection{From Desc to IDesc}

\begin{wstructure}
<- Labelling Id
    <- We had: data Desc : Set -> Set
    -> We want: data IDesc : (I -> Set) -> Set
        <- Indexed functor (?)
        -> It is sufficient to label Id
            <- Where the functor is built
\end{wstructure}

In the previous section, we have presented the $\Desc$ universe as the
grammar of functors in the category $\Set$. We have seen how to code
inductive types in this setting. To describe an inductive family
indexed by $\Bhab{\V{I}}{\Set}$, we use endofunctors on the category
$\Set^{\V{I}}$. We call these \emph{indexed functors}. \note{Predicate
  transformer anyone?} In this setting, $\V{I} \To \IDesc{\V{I}}$ is our
grammar for describing these functors. Hence, $\IDesc{\!}$ and its
interpretation have the following types:

\[\stk{
\data \IDesc{\!} (\Bhab{\V{I}}{\Set}) : \Set \where \\
\;\;\ldots \\
\\
\idescop{\_\:}{}{} : \PI{\V{I}}{\Set} \IDesc{\V{I}} \To (\V{I} \To \Set) \To \Set    \\
\ldots
}\]

Note that $I \To \IDesc{\V{I}}$ is isomorphic, up to interpretation, to an
endofunctor on $\Set^{\V{I}}$. Indeed, $\V{I} \To \IDesc{\V{I}}$ is interpreted as
$\V{I} \To (\V{I} \To \Set) \To \Set$, which is isomorphic to $(\V{I} \To \Set)
\To (\V{I} \To \Set)$. Fix-point of inductive families is defined over
these indexed functors, hence computing a fix-point of the entire
\emph{family} of functors:

\[\stkl{
\Rule{\stk{ 
          \Gamma \vdash \Bhab{\V{I}}{\Set} \\
          \Gamma \vdash \Bhab{\V{R}}{\V{I} \To \IDesc{\V{I}}} \\
          \Gamma \vdash \Bhab{\V{i}}{\V{I}}}}
     {\Gamma \vdash \Bhab{\IMu{\V{I}}{\V{R}}{\V{i}}}{\Set}} \qquad
\Rule{\stk{
          \Gamma \vdash \Bhab{\V{I}}{\Set} \\
          \Gamma \vdash \Bhab{\V{R}}{\V{I} \To \IDesc{\V{I}}} \\
          \Gamma \vdash \Bhab{\V{i}}{\V{I}} \\
          \Gamma \vdash \Bhab{\V{x}}{\idescop{\V{R}\: \V{i}}{\V{I}}{(\IMu{\V{I}}{\V{R}}{})}}}}
     {\Gamma \vdash \Bhab{\Con{\V{x}}}{\IMu{\V{I}}{\V{R}}{\V{i}}}}
}\]


However, we still have to define the actual grammar. This can be
achieved by a minor evolution of $\Desc$
(Fig.~\ref{fig:type-former-desc}). Indeed, the functorial nature of
$\Desc$ is entirely captured by the $\DId$ code. We get an indexed
functor by turning $\DId$ into an index-dependent $\DVar{\!}$
code. The resulting code of $\IDesc{\!}$ is presented in
Figure~\ref{fig:idesc}.

%% \[\stk{
%% \data \IDesc{} (\Bhab{\V{I}}{\Set}) : \Set \where \\
%% \;\;\begin{array}{@{}l@{\::\:\:}l@{\quad}l}
%%     \DVar{}         & I \To \IDesc{I}                                   \\
%%     \ldots          & \ldots
%% \end{array} \\
%% \\
%% \idescop{\_\:}{}{} :_{\PI{\V{I}}{\Set}} \IDesc{I} \To (\V{I} \To \Set) \To \Set        \\
%% \begin{array}{@{}l@{\:=\:\:}ll}
%% \idescop{\DVar{i}}{I}{P}      &  P~i                                                 \\
%% \ldots                        &  \ldots
%% \end{array}
%% }\]

\begin{figure}

\[\stk{
\begin{array}{ll}
\stk{
\data \IDesc{\!} (\Bhab{\V{I}}{\Set}) : \Set \where \\
\;\;\begin{array}{@{}l@{\::\:\:}l@{\quad}l}
    \DVar{\!}         & \V{I} \To \IDesc{\V{I}}                                       \\
    \DConst{\!}       & \Set \To \IDesc{\V{I}}                                        \\
    \DProd{\!}{\!}    & \PI{\V{\V{D}}, \V{\V{D'}}}{\IDesc{\V{I}}} \IDesc{\V{I}}       \\
    \DSigma{\!}{\!}   & \PI{\V{S}}{\Set} \PIS{\V{S} \To \IDesc{\V{I}}} \IDesc{\V{I}}  \\
    \DPi{\!}{\!}      & \PI{\V{S}}{\Set} \PIS{\V{S} \To \IDesc{\V{I}}} \IDesc{\V{I}} 
\end{array}
}
\vspace{0.2in}
\\
\stk{
\idescop{\_\:}{}{} :_{\PI{\V{I}}{\Set}} \IDesc{\V{I}} \To (\V{\V{I}} \To \Set) \To \Set                  \\
\begin{array}{@{}l@{\:=\:\:}ll}
\idescop{\DVar{\V{i}}}{\V{I}}{\V{P}}      &  \V{P}~\V{i}                                                 \\
\idescop{\DConst{\V{X}}}{\V{I}}{\V{P}}    &  \V{X}                                                   \\
\idescop{\DProd{\V{D}}{\V{D'}}}{\V{I}}{\V{P}} &  \TIMES{\idescop{\V{D}}{\V{I}}{\V{P}}}{\idescop{\V{D'}}{\V{I}}{\V{P}}}       \\
\idescop{\DSigma{\V{S}}{\V{D}}}{\V{I}}{\V{P}} &  \SIGMA{\V{s}}{\V{S}} \idescop{\V{D}\: \V{s}}{\V{I}}{\V{P}}                    \\
\idescop{\DPi{\V{S}}{\V{D}}}{\V{I}}{\V{P}}    &  \PI{\V{s}}{\V{S}} \idescop{\V{D}\: \V{s}}{\V{I}}{\V{P}}            
\end{array}
}
\end{array}
}\]

\caption{Universe of indexed description}
\label{fig:idesc}

\end{figure}

%\subsection{Tagged indexed descriptions}

% This discussion seemed out of place to me, so i've moved it a bit later (pwm).

%\begin{wstructure}
%<- Tagged constructor choice
%    <- Index available when defining the data-type
%        -> Can influence the choice of constructors
%        -> Dependently-typed data-types
%            <- term (index) influence types
%    -> Two parts
%        <- Always on the menu
%            <- E : EnumU 
%            <- ED : E -> IDesc I
%        <- Index-dependent
%            <- F : I -> EnumU 
%            <- FD : (i : I) -> spi (F i) (\_ -> IDesc I)
%        -> taggedIDesc I == Sigma E ED x Sigma F FD
%        -> toIDesc : (I : Set) -> taggedIDesc I -> (I -> IDesc I)
%\end{wstructure}
%
%In Section~\ref{sec:desc-examples}, we have defined a \emph{tagged}
%form for descriptions. This format follows the usual presentation of
%inductive types as sum-of-product. With indexed description, this
%definition can be generalized. Indeed, when defining an indexed
%data-type, we have access to this index. Therefore, we can use this
%index to influence the choice of constructors. This captures the
%essence of dependent data-types: a term -- the index -- has the
%ability to influence the data-type.
%
%For convenience, we divide a tagged indexed description in two parts:
%first, the constructors that do not depend on the index; then, the
%constructors that do. The non-dependent part mirrors the definition
%for non-indexed descriptions: we are provided a finite choice of
%constructors. The index-depend part simply indexes the choice of
%constructors by $I$. Hence, by inspecting the index, it is possible to
%enable or disable the constructors. 
%
%\[\stk{
% \TagIDesc{\V{I}}  \mapsto \TIMES{\ATagIDesc{\V{I}}}{\ITagIDesc{\V{I}}} \\
% \ATagIDesc{\V{I}} \mapsto \SIGMA{\V{E}}{\EnumU} (\PI{\V{i}}{\V{I}} \spi{\V{E}}{(\LAM{\_} \IDesc{\V{I}})}) \\
% \ITagIDesc{\V{I}} \mapsto \\
%\qquad\SIGMA{\V{F}}{\V{I} \To \EnumU} (\PI{\V{i}}{\V{I}} \spi{(\V{F}\: \V{i})}{(\LAM{\_} \IDesc{\V{I}})}) 
%}\]
%
%
%\begin{wstructure}
%<- Vectors
%    Do we treat them in the end? 
%    What can we say here we haven't with Fin?
%\end{wstructure}
%
%In the case of vectors, for instance, for the index $\NatZero$, we
%would only propose the constructor $\ListNil$. Similarly, for
%$\NatSuc{n}$, we only propose the constructor $\ListCons{\!}{\!}$. Hence,
%we obtain the following definition:
%
%\newcommand{\VecD}{\C{VecD}}
%\newcommand{\VecNil}{\etag{\CN{vnil}}}
%\newcommand{\VecCons}[2]{\etag{\CN{vcons}}\:#1\:#2}
%
%\[\stk{
%\VecD : \Set \To \TagIDesc{\Nat} \\
%\begin{array}{@{}ll}
%\VecD\: \V{X} = \\ \quad\bigRedBracket{ 
%            \begin{array}{l}
%                \pair{[]}{\_}{} 
%                \\\\
%                \bigRedBracket{
%                \begin{array}{l} 
%                  \LAM{\V{n}} \caseB{\V{n}}{\NatZero \mapsto [\VecNil] \\
%                                   (\NatSuc{\V{n}}) \mapsto [\VecCons{\!}{\!}]} \\
%                  \LAM{\V{n}} \caseB{\V{n}}{\NatZero \mapsto [\DConst{\Unit}] \\
%                                   (\NatSuc{\V{n}}) \mapsto [\DSigma{\V{X}}{\DVar{\V{n}}}]}
%                \end{array}}
%            \end{array}}
%\end{array}
%}\]
%
%We will see more instances of this pattern in the following.


\note{Should we say something about IMu, fixed-points, and their
  elimination before moving on? If so, where should we put it?}

\subsection{Examples}
\label{sec:idesc-examples}

\paragraph{Natural numbers:}

\begin{wstructure}
<- Nat
    -> [equation]
    <- Non-indexed types lives in IDesc 1
        -> This applies to all previous examples
\end{wstructure}

In order to gain some intuition with $\IDesc{\!}$, let us re-implement
the pattern functor of natural numbers. This follows the implementation of
$\NatD$ from \ref{sec:idesc-atomic-desc}:

\[\stk{
\NatD : \IDesc{\Unit} \\
\NatD \mapsto \DSigma{(\EnumT{[ \NatZero, \NatSuc{\!} ]})}
                     {[ (\DConst{\Unit}) \quad (\DVar{\Void}) ]}
}\]

Because $\Nat$ is just an inductive type, $\NatD$ represents a
$\Unit$-indexed functor. Therefore, the recursive
argument is materialised by $\DVar{\Void}$, where we were using $\DId$
in the $\Desc$ presentation. Indeed, all inductive types can be
translated into $\IDesc{\!}$ in exactly this way.



\paragraph{Indexed descriptions:}

\begin{wstructure}
<- Levitation [figure]
    <- Following Desc encoding
        /> Note: simple data-type
            -> Live in IDesc 1
    -> Behind the scene, relies on the special purpose switchD
\end{wstructure}

If we note that, for any $\V{I}$, $\IDesc{\V{I}}$ itself is merely an inductive 
\emph{type} then we can certainly define its encoding in $\IDesc{\Unit}$:

\[\stk{
\IDescD : \PI{\V{I}}{\Set} \IDesc{\Unit} \\
\begin{array}{@{}ll}
\IDescD~\V{I} \mapsto \DSigma{\!}{\!} & (\EnumT \red{[} 
                                          \DVar{\!},
                                          \DConst{\!},
                                          \DProd{\!}{\!},
                                          \DSigma{\!}{\!}, 
                                          \DPi{\!}{\!}
                                             \red{]}) \\
                              & \bigRedBracket{\begin{array}{l}
                                      \DConst{\V{I}}                  \\
                                      \DConst{\Set}               \\
                                      \DProd{\DVar{\Void}}{\DVar{\Void}}  \\
                                      \DSigma{\Set}{(\LAM{\V{S}} \DPi{\V{S}}{(\LAM{\_} \DVar{\Void})})} \\
                                      \DSigma{\Set}{(\LAM{\V{S}} \DPi{\V{S}}{(\LAM{\_} \DVar{\Void})})}
                                   \end{array}
                             }
\end{array}
}\]

Using this description we can repeat the act of levitation 
from section~\ref{sec:desc-levitate}. As before we rely on a special purpose 
$\F{switchID}$ operator to build the finite function space
$\bigRedBracket{\ldots}$. 

\paragraph{Vectors:}

\newcommand{\VecD}{\C{VecD}}
\newcommand{\VecNil}{\etag{\CN{vnil}}}
\newcommand{\VecCons}[2]{\etag{\CN{vcons}}\:#1\:#2}

So far, the examples we have seen lives in $\IDesc{\Unit}$, hence are
not using any indexing. We remedy this by encoding the vectors:

Recall that the constructors of $\D{Vec}$. The constructors $\VecNil$ and
$\VecCons$ are only defined for an index $\NatZero$ and $\NatSuc$ 
respectively.:


\[
\stk{
\data \D{Vec}\: \PITEL{\V{X}}{\Set} : \PI{\V{n}}{\Nat} \Set \where \\
\;\;\begin{array}{@{}l@{\::\:\:}l@{\quad}l}
    \VecNil      & \D{Vec}\:\V{X}\:{\NatZero)}   \\
    \VecCons     & _{\PI{\V{n}}{\Nat}}\V{X} \To \D{Vec}\:{\V{X}}\:{\V{n}} \To \D{Vec}\:{\V{X}}\:{(\NatSuc{\V{n}})}
\end{array}
}
\]

One way to code constrained data-type is to appeal to equality. The
constraints are therefore captured by equations in the data-type. In
this case, we obtain the following definition:

\[\stk{
\VecD : \Set \To \Nat \To \IDesc{\Nat} \\
\begin{array}{@{}ll}
\VecD\: \V{X}\: \V{n} = \DSigma{\!}{\!} \!\!\!\!& (\EnumT{[ \VecNil , \VecCons{\!}{\!} ]}) \\
                        & \bigRedBracket{
                          \begin{array}{l}
                            \DConst{(\V{n} \PropEq \NatZero)} \\
                            \DSigma{\Nat}{\LAM{\V{m}} \stk{\DProd{\DVar{\V{m}}}{\\\DConst{(\V{n} \PropEq \NatSuc{\V{m}})}}}}
                          \end{array}
                          }
\end{array}
}\]

If the $\VecNil$ tag is chosen, a proof must be provided that the index is equal
to $\NatZero$. In the $\VecCons$ case, we first store an
element $\V{m}$ of $\Nat$, with a $\DSigma{\!}{\!}$. However, the
constraint stipulates that $\V{m}$ cannot be \emph{any} natural
numbers: it must be ``the index minus one''. This translates into the
constraint $\V{n} \PropEq \NatSuc{\V{m}}$.

However, one could, quite rightfully, be worried by the introduction
of equalities in the picture. In a programming context, equalities
haunt us, begging for proofs. Hence, whereas the developer typed a
constructor-constrained data-type, the elimination form will involve
equalities and their proofs. As much as possible, one would rather
avoid suffering from this burden. However, the equalities introduced
here are rather special: they are \emph{equations} constraining
variables to certain terms. Goguen et
al.~\cite{goguen:pattern-matching} have shown, in the context of
dependent pattern matching, how to tame these equations.

\begin{wstructure}
!!! Need Help !!!
<- Brady optimisation: forcing
    <- Source to source translation
    <- Able to remove some constraints
    -> Example: Fin [figure]
    ??? More technical detail needed
\end{wstructure}

Further, we can actually remove these equations altogether. Let us look back
at $\D{Vec}$. We note that the equations are introduced because we are
\emph{storing} the index of the inductive family.  However, \emph{inductive
families need not store their indices}~\cite{brady:index-inductive-families}.
By examining the in coming index, we can apply the \emph{forcing} and
\emph{de-tagging} optimisations to our initial definition of $\D{Vec}$ gives
the following, equivalent definition:

\[\stk{
\VecD \:\PITEL{\V{X}}{\Set} : \Nat \To \IDesc{\Nat} \\
\begin{array}{@{}lll}
\VecD\:\V{X}\: \NatZero     & = & \DConst{\Unit} \\
\VecD\:\V{X}\: (\NatSuc{\V{n}}) & = & \DProd{\DConst{\V{X}}}{\DVar{\V{n}}}
\end{array}
                                       
}\]

The equations (and constructors) have simply disappeared. Note that it is
straightforward to turn this definition into a tagged form, where in each
case, only one constructor choice is available to the developer. In another
example, $\Fin{\!}$, we can force, but not detag, since both $\FinZero$ and 
$\FinSuc{\!}$ both target $\NatSuc{\!}$:

\[
\stk{
\data \Fin{\!} : \PI{\V{n}}{\Nat} \Set \where \\
\;\;\begin{array}{@{}l@{\::\:\:}l@{\quad}l}
    \FinZero_{\V{n}}      & \Fin{(\NatSuc{\V{n}})}   \\
    \FinSuc{\!}_{\V{n}}   & \Fin{\V{n}} \To \Fin{(\NatSuc{\V{n}})}
\end{array}
\vspace{0.1in}
\\
\FinD : \Nat \To \IDesc{\Nat} \\
\begin{array}{@{}llll}
\FinD\: \NatZero     & = & \multicolumn{2}{l}{\DSigma{(\EnumT{[]})}{\Void} } \\
\FinD\: (\NatSuc{\V{n}}) & = & \DSigma{\!}{\!}\!\!\!\!\! & (\EnumT{[ \FinZero , \FinSuc{\!} ]}) \\
                     &   &             & \bigRedBracket{
                                         \begin{array}{l}
                                         \DConst{\Unit} \\
                                         \DVar{\V{n}}
                                         \end{array}
                                         }
\end{array}
}\]

We should
precise that forcing a description is not guaranteed to remove all
constraints. It is subject to future work to see if constraints can be
entirely eradicated, or presented more conveniently to the developer.
Finally, it is worth mentioning that these optimisations are 
\emph{source-to-source} transformations on descriptions.

\subsubsection{Tagged Indexed Descriptions}

In Section~\ref{sec:desc-examples}, we have defined a \emph{tagged}
form for descriptions. This format follows the usual presentation of
inductive types as sum-of-product. With indexed description, this
definition can be generalized. Indeed, when defining an indexed
data-type, we have access to this index. Therefore, we can use this
index to influence the choice of constructors. This captures the
essence of dependent data-types: a term -- the index -- has the
ability to influence the data-type.

For convenience, we divide a tagged indexed description in two parts:
first, the constructors that do not depend on the index; then, the
constructors that do. The non-dependent part mirrors the definition
for non-indexed descriptions: we are provided a finite choice of
constructors. The index-depend part simply indexes the choice of
constructors by $\V{I}$. Hence, by inspecting the index, it is possible to
e

\[\stk{
 \TagIDesc{\V{I}}  \mapsto \TIMES{\ATagIDesc{\V{I}}}{\ITagIDesc{\V{I}}} \\
 \ATagIDesc{\V{I}} \mapsto \SIGMA{\V{E}}{\EnumU} (\PI{\V{i}}{\V{I}} \spi{\V{E}}{(\LAM{\_} \IDesc{\V{I}})}) \\
 \ITagIDesc{\V{I}} \mapsto \\
\qquad\SIGMA{\V{F}}{\V{I} \To \EnumU} (\PI{\V{i}}{\V{I}} \spi{(\V{F}\: \V{i})}{(\LAM{\_} \IDesc{\V{I}})}) 
}\]


\begin{wstructure}
<- Vectors
    Do we treat them in the end? 
    What can we say here we haven't with Fin?
\end{wstructure}

In the case of a tagged $\D{Vec}$, for instance, for the index $\NatZero$, we
would only propose the constructor $\ListNil$. Similarly, for
$\NatSuc{n}$, we would only propose the constructor $\ListCons{\!}{\!}$. We
will see a concrete example of this in the following example. 
 
\paragraph{Typed expressions:}

\begin{wstructure}
<- Hutton's razor
    <- Types
        <- 'Nat
        <- 'Bool
    <- Term [figure]
        <- val : Val 'a -> 'a  for Val : Ty -> Set, mapping to Nat and Bool
        <- cond : 'Bool -> a -> a -> a
        <- plus : 'Nat -> 'Nat -> 'Nat
        <- le : 'Nat -> 'Nat -> 'Bool
\end{wstructure}

%% Types
\newcommand{\Ty}{\C{Ty}}
\newcommand{\Ebool}{\etag{\CN{bool}}}
\newcommand{\Enat}{\etag{\CN{nat}}}

%% Constructors
\newcommand{\Eval}[1]{\etag{\CN{val}}~#1}
\newcommand{\Econd}[3]{\etag{\CN{cond}}~#1~#2~#3}
\newcommand{\Eplus}[2]{\etag{\CN{plus}}~#1~#2}
\newcommand{\Ele}[2]{\etag{\CN{le}}~#1~#2}

%% Index mapper (terminology?)
\newcommand{\Val}[1]{\D{Val}~#1}
\newcommand{\Var}[2]{\D{Var}_{#1}~#2}

%% Hutton expressions
\newcommand{\HExprD}{\C{ExprD}}
\newcommand{\HExprAD}{\C{ExprAD}}
\newcommand{\HExprID}{\C{ExprID}}
\newcommand{\HExprVarD}[1]{\C{ExprD}_{\C{Var},#1}}
\newcommand{\HExprFreeD}{\C{ExprD}^{\C{Free}}}
\newcommand{\HExprAFreeD}{\C{ExprAlwaysD}^{\C{Free}}}

We are going to define a syntax for a small
typed language. We consider two types, natural numbers and booleans:

\[
\Ty \mapsto \EnumT{[\Enat, \Ebool]}
\]

An expression of this language is either a value, a conditional
expression, addition of numbers, or comparison of numbers. Informally,
their type is the following:

\[
\begin{array}{l@{\::\:\:}l}
\Econd{}{}{}     & \forall \Bhab{\V{ty}}{\Ty} . \Ebool \To \V{ty} \To \V{ty} \To \V{ty}  \\ 
\Eplus{}{}       & \Enat \To \Enat \To \Enat                           \\
\Ele{}{}         & \Enat \To \Enat \To \Ebool                          \\
\Eval{}          & \forall \Bhab{\V{ty}}{\Ty} . \Val{\V{ty}} \To \V{ty}
\end{array}
\]

The function $\Val{}$, used in the definition of $\Eval{}$, simply
maps an object type $ty$ to the corresponding type in the host
language. Hence, the argument of $\Eval{}$ are ensured to be of the
expected type. We assume $\Nat$ and $\Bool$ represent natural numbers
and booleans in the host language. Further, we also assume the
existence of an addition and comparison operator in $\Nat$,
respectively named $\F{plusHost}$ and $\F{leHost}$. We define $\Val{}$
as follow:

\[\stk{
\Val{} : \Ty \To \Set \\
\begin{array}{@{}l@{\:=\:\:}l}
\Val{\Enat}   & \Nat \\
\Val{\Ebool}  & \Bool
\end{array}
}\]

In our universe of descriptions, this data-type is represented by a
tagged indexed description. We use the index to carry the type: the
resulting description is indexed by $\Ty$. We observe that some
constructors are ``polymorph'', namely $\Econd{}{}{}$ and $\Eval{}$. On the
other hand, the $\Eplus$ and $\Ele$ constructors are
index-dependent. $\Eplus$ is defined if and only if the result type --
the index -- is $\Enat$, whereas $\Ele$ is defined if and only if the
index is $\Ebool$. The actual code precisely follows this intuition,
as shown in Figure~\ref{fig:hexpr-full}. For brevity, we use an
informal $\case{\ldots}{\ldots}$ notation, simulating a definition by
pattern-matching. Formally, this corresponds to a call to the
$\switch{\!}{\!}{\!}{\!}$ eliminator.

\begin{figure}

\[\stk{
\stk{
\HExprD : \TagIDesc{\Ty} \\
\HExprD \mapsto ( \HExprAD , \HExprID ) \\
} \\
\\
\stk{
\HExprAD : \ATagIDesc{\Ty} \\
\HExprAD \mapsto \bigRedBracket{
                 \begin{array}{l}
                   \EnumT{[\Eval{}, \Econd{\!}{\!}{\!}\!\,]} \red{,} \\
                   \LAM{\V{ty}}
                   \bigRedBracket{
                   \begin{array}{l}
                   \DConst{(\Val{\V{ty}})} \\
                   \DProd{\DVar{\Ebool}}{\DProd{\DVar{\V{ty}}}{\DVar{\V{ty}}}}
                   \end{array}
                   }
                 \end{array}
                 }
\\
\\
} 
\\
\stk{
\HExprID : \ITagIDesc{\Ty} \\
\HExprID \mapsto \bigRedBracket{
                 \begin{array}{l}
                   \LAM{\V{ty}} \case{\V{ty}}{\Enat \To \EnumT{[\Eplus{\!}{\!}\!\,]} \\ \Ebool \To \EnumT{[\Ele{\!}{\!}\!\,]}} \red{,} \\
                   \LAM{\_} \DProd{\DVar{\Enat}}{\DVar{\Enat}} 
                   \end{array}
                   }
}
}\]

\caption{Syntax of typed expressions}
\label{fig:hexpr-full}

\end{figure}

\begin{wstructure}
    -> evaluation: IMu TermD -> Val
        -> it is a catamorphism
            <- Look closer at the type
        -> implementation [code]
            <- Just define one reduction step
            -> cata does the rest
                /> cata is for free!
\end{wstructure}

\newcommand{\evalH}{\F{eval}_{\green{\Downarrow}}}
\newcommand{\evalOne}{\F{eval}_{\green{\downarrow}}}

Having implemented the syntax, we would like to describe its
semantics. To do so, we implement an evaluator. The type of the
evaluator is:

\[
\evalH : \PI{\V{ty}}{\Ty} 
         \IMu{\Ty}{\toIDesc{\HExprD}}{\V{ty}} \To
         \Val{\V{ty}}
\]

The type of $\F{eval}$ is strikingly similar to a
catamorphism. Indeed, implementing a single step of evaluation -- the
algebra -- is sufficient, as $\F{cataI}$ \note{We have not defined
  \F{cataI}!} gives, for free, the full evaluator. The implementation
is as follow:


\[\stk{
\evalOne : \PI{\V{ty}}{\Ty} \idescop{\toIDesc{\HExprD}\: \V{ty}}{\Ty}{\V{ty}}
\To {\Val{\V{ty}}} \\
\begin{array}{@{}l@{\:=\:\:}l}
\evalOne\: \_\: \pair{\Eval{}}{\V{x}}{}                                         & \V{x} \\
\evalOne\: \_\: \pair{\Econd{}{}{}}{\pair{\BoolTrue}{\pair{\V{x}}{\_}{}}{}}{}   & \V{x} \\
\evalOne\: \_\: \pair{\Econd{}{}{}}{\pair{\BoolFalse}{\pair{\_}{\V{y}}{}}{}}{}  & \V{x} \\
\evalOne\: \Enat\: \pair{\Eplus{}{}}{\pair{\V{x}}{\V{y}}{}}{}                       & \F{plusHost}\: \V{x}\: \V{y} \\
\evalOne\: \Ebool\: \pair{\Ele{}{}}{\pair{\V{x}}{\V{y}}{}}{}                        & \F{leHost}\: \V{x}\: \V{y} 
\end{array} \\
\\
\evalH : \PI{\V{ty}}{\Ty} 
           \IMu{\Ty}{\toIDesc{\HExprD}}{\V{ty}} \To
           \Val{\V{ty}} \\
\evalH\: \V{ty}\: \V{term} = \F{cataI}\: \Ty\: 
                                 \toIDesc{\HExprD}\: 
                                 \Val{}\: 
                                 \evalOne\: 
                                 \V{ty}\: 
                                 \V{term}
}\]
\note{pwm: $\evalOne$ rather illustrates my point about the 2 types of
  IFunc floating around, $\idescop{\_}{}{}$ is defined using the 1st
  notion, and used it here as if it were the 2nd. pierre: in this
  case, it was a typo. But you're right, there is two notions and we
  probably want to clarify where these things live.}

\begin{wstructure}
    /> Closed term
        <- only constants and operations on them
        -> Extend Val with Var : Ty -> Set, mapping to EnumU
            -> Open term
            -> Language of well-typed terms
                <- By construction
\end{wstructure}

Hence, we have defined the syntax of a typed language of arithmetic
and boolean operations. We have given its semantics through an
evaluation function. Provided a one step semantic of the language, the
big step evaluation is granted without effort thanks to the generic
catamorphism. 

However, so far, we are only able to define and manipulate
\emph{closed} terms. By abstracting over $\Val{}$, it is possible to
build and manipulate \emph{open} terms, that is terms with symbolic
variables. On the model of $\Val{}$, we define $\Var{}{}$:

\[\stk{
\Var{}{} : \EnumU \To \Ty \To \Set \\
\Var{\V{dom}}{\_} = \EnumT{\V{dom}}
}\]

Whereas $\Val{}$ was mapping the type to the corresponding host type,
$\Var{}{}$ maps types to a finite set. The finite set -- the context
-- contains closed terms. A variable is therefore a $\Eval{}$ that
contains a pointer to a particular element of the finite set -- an
element of $\EnumT{\V{dom}}$. The extra argument to $\Var{}{}$ is the
domain of this context.

Consequently, replacing $\Val{\V{ty}}$ by
$(\SUM{\Val{\V{ty}}}{\Var{\V{dom}}{\V{ty}}})$ in Figure~\ref{fig:hexpr-full} turns
the language of closed term into a language of opened terms with
constants. For readability, we will abbreviate $\LAM{\V{ty}}
\SUM{\Val{\V{ty}}}{\Var{\V{dom}}{\V{ty}}}$ into $\SUM{\Val{}}{\Var{}{}}$ \note{Is
  it polite and comprehensible to ask that?} This defines a new
indexed description, called $\HExprVarD{\V{dom}}$.

\begin{wstructure}
        <- evaluator, with a context
            -> First, close variables
                -> Perform assignment
                <- subst [code]
\end{wstructure}

\newcommand{\discharge}{\F{discharge}}

Again, we would like to give a semantics to this extended language. We
proceed in two steps: first, we replace the variables by their value
in the context; then, we evaluate the resulting closed term. Thanks to
$\evalH$, we are already able to solve the second problem. Let us
focus on discharging variables from the context. Again, we can
subdivide this problem: first, we need the ability to discharge a
single variable from the context; then, we apply this $\discharge$
function on every variables in the term.

The $\discharge$ function is relative to the required type, the domain
of the context, and a context containing values of the corresponding
type. Its action is to map variables to their value in context, and
directly return constant values. This corresponds to the following
function:

\[\stk{
\begin{array}{@{}ll}
\discharge : & \PITEL{\V{ty}}{\Ty}
               \PITEL{\V{dom}}{\EnumU} \\
             & \PI{\V{\gamma}}{\spi{\V{dom}}{(\LAM{\_} \IMu{\Ty}{\toIDesc{\HExprVarD{\V{dom}}}}{\V{ty}})}} \\
             & (\SUM{\Val{\V{ty}}}{\Var{\V{dom}}{\V{ty}}}) \To
               \IMu{\Ty}{\toIDesc{\HExprD}}{\V{ty}} 
\end{array} \\
\begin{array}{@{}l@{\:\mapsto\:\:}l}
\discharge\: \V{ty}\: \V{dom}\: \V{\gamma}\: (\SumLeft \V{x})  & \Con{\pair{\Eval{}}{\V{x}}{}} \\
\discharge\: \V{ty}\: \V{dom}\: \V{\gamma}\: (\SumRight \V{v}) &
\end{array}\\
\qquad\switch{\V{dom}}{(\LAM{\_}
\IMu{\Ty}{\toIDesc{\HExprVarD{\V{dom}}}}{\V{ty}})}{\V{\gamma}}{\V{v}}
}\]

\begin{wstructure}
            /> Then, perform subst everywhere in the term
                -> Show type [code]
                /> This is a bind!?
                -> There is some more structure 
                    -> We should try to get it
\end{wstructure}

Having implemented the local $\discharge$ operation, we are left with
applying it over all variables of the term. The type of this operation
is the following:

\newcommand{\substH}{\F{substExpr}}
\newcommand{\domNat}{dom_{\CN{nat}}}
\newcommand{\domBool}{dom_{\CN{bool}}}
\newcommand{\gammaNat}{\V{\ensuremath{\gamma_{\CN{nat}}}}}
\newcommand{\gammaBool}{\V{\ensuremath{\gamma_{\CN{bool}}}}}
\newcommand{\GammaSpi}[2]{\F{\ensuremath{\Gamma_{\CN{ty}}}}~#1~#2}

\[
\begin{array}{@{}ll}
\substH  : & \PITEL{\V{\dom}}{\EnumU} \\
           & \PITEL{\V{\gammaNat}}{\GammaSpi{\V{dom}}{\Enat}} 
             \PITEL{\V{\gammaBool}}{\GammaSpi{\V{dom}}{\Ebool}} \\
           & \begin{array}{@{}ll}
             \PI{\V{\sigma}}{& \PITEL{\V{dom}}{\EnumU} \\
                             & \PITEL{\V{\gammaNat}}
                                     {\GammaSpi{\V{dom}}{\Enat}} \\
                             & \PITEL{\V{\gammaBool}}
                                     {\GammaSpi{\V{dom}}{\Ebool}} \\
                             & \PI{\V{ty}}{\Ty} (\SUM{\Val{\V{ty}}}{\Var{\V{dom}}{\V{ty}}}) \To \\
                             & \IMu{\Ty}{\toIDesc{\HExprD}}{\V{ty}}}
             \end{array}\\
          & \PI{\V{ty}}{\Ty}
            \IMu{\Ty}{\toIDesc{\HExprVarD{\V{dom}}}}{\V{ty}} \To \\
          & \IMu{\Ty}{\toIDesc{\HExprD}}{\V{ty}}
\end{array}
\]

Where $\GammaSpi$ corresponds to a context, defined by:

\[\stk{
\GammaSpi{}{} : \EnumU \To \Ty \To \Set                                             \\
\GammaSpi{\V{dom}}{\V{ty}} = \spi{\V{dom}}{(\LAM{\_} \IMu{\Ty}{\toIDesc{\HExprVarD{\V{dom}}}}{\V{ty}})} 
}\]


Abstracting away the book-keeping introduced by the context, this
definition looks familiar. Indeed, it is extremely similar to a
monadic \bind. This is not surprising as we are defining a first-order
syntax with variables: our data-type enjoys more structure than what
we are given. In particular, this is reminiscent to a free monad,
where $\Eval{}$ is the \return\ introducing variables. The substitution
$\V{\sigma}$ is implemented from $\discharge$, by picking the domain and
context corresponding to the type:

\[
\F{$\sigma$}\: \V{dom}\: \gammaNat\: \gammaBool\: \V{ty}\: \V{var} \mapsto
    \F{$\discharge$}\: \V{ty}\: \V{dom}\: \F{$\gamma$}_{\V{ty}}\: \V{var} 
\]

Where $\F{$\gamma$}_{\V{ty}}$ is short for
 $\caseB{\V{ty}}{\Enat  \To \gammaNat \\
                 \Ebool \To \gammaBool}$

Instead of implementing $\substH$ in this special case, we can
implement it in a generic setting, a \emph{free indexed-monad construction}
that we will see in the next section.

\subsection{Free IMonad}

\begin{wstructure}
<- Variation on a theme: free imonad construction
    <- Recall existence of generic free monad construction
    -> Present its generalisation to IDesc [equation]
        <- \I -> IDesc I as describing an indexed endofunctor
        <- Free monad construction
    -> Still a suitable, generic notion of substitution
        <- show type signature
        <- show implementation?? (space! space!)
\end{wstructure}

In this section, we develop more structure for our indexed
data-types. In Section~\ref{sec:desc-free-monad}, we have built a free
monad operation for simple descriptions. Building on this experience,
we are going to present its equivalent in the indexed world. The
process the same. Namely, given an indexed functor, we derive the
indexed functor coding its free monad: \note{pwm: Whoa there. Maybe we
  should say something about IMonads in general before we get to this
  point?}

\[\stk{
\begin{array}{ll}
\FreeIMonad{\_}{} : & _{\PITEL{\V{I}}{\Set}}
                     \PITEL{\V{R}}{\TagIDesc{\V{I}}} 
                     \PITEL{\V{X}}{\V{I} \To \Set}\To 
                      \TagIDesc{\V{I}}
\end{array} \\
\FreeIMonad{(\V{E},\V{F})}{\V{I}}{\V{R}} \mapsto \\ \;\;
    \pair{\pair{\ListCons{\DVar{\!}}{(\fst{\V{E}})}} 
               {\LAM{\V{i}}
                \pair{(\DConst{(\V{R}\: \V{i})})}
                     {((\snd{\V{E}})\: \V{i})}{}}{}}
         {\V{F}}{}
}\]

Just as in the universe of descriptions, this construction comes with
an obvious \return\ and a substitution operation, the \bind. Its type
signature is the following:

\newcommand{\substI}{\F{substI}}

\[
\begin{array}{@{}ll}
\substI : & \PITEL{\V{I}}{\Set}
            \PITEL{\V{X}, \V{Y}}{\V{I} \To \Set}
            \PITEL{\V{R}}{\TagIDesc{\V{I}}} \\
          & \PITEL{\V{\sigma}}{\PI{\V{i}}{\V{I}} \V{X}\:\V{i} \To 
                               \IMu{\V{I}}{(\toIDesc{\FreeIMonad{\V{R}}{\V{I}}{\V{Y}}})}{\V{i}}} \\
          & \PITEL{\V{i}}{\V{I}}
            \PITEL{\V{D}}{\IMu{I}{(\toIDesc{\FreeIMonad{\V{R}}{\V{I}}{\V{X}}})}{\V{i}}} \To
            \IMu{I}{(\toIDesc{\FreeIMonad{\V{R}}{\V{I}}{\V{Y}}})}{\V{i}}
\end{array}
\]


\subsubsection{Examples}

\paragraph{Typed expressions:}

\begin{wstructure}
<- Hutton's razor is a free monad
    <- substI was our candidate bind
        -> Massage the definition of expr to get it for free
    <- Finding the functor
        <- 'val is the return
        <- The other components are the action
        -> Updated tagged description [figure]
    -> Compute the free monad Hutton * X
        -> With X = Val: We get back our closed terms
        -> With X = Val + Var vars: We get back our open terms
\end{wstructure}

In Section~\ref{sec:idesc-examples}, we had the intuition that our
datatypes $\HExprD$ and $\HExprVarD{\V{dom}}$ enjoy a monadic structure. We had
identified the variable substitution operation as the \bind\ of a free
monad. The definition of $\substI$ above confirm our intuition: using
$\substI$, we should easily obtain $\substH$. To do so, we first have
to massage the definition of our data-type, to exhibit its monadic
structure.

As previously mentioned, we identify $\Eval{}$ as the \return\ of the
free monad, while the other components are the action of the monad. As
a result, the definition is similar to $\HExprD$ presented in
Figure~\ref{fig:hexpr-full}, at the exception of $\HExprAD$ that is
replaced by $\HExprAFreeD$:

\[\stk{
\HExprAFreeD : \ATagIDesc{\Ty} \\
\HExprAFreeD \mapsto \bigRedBracket{
                 \begin{array}{l}
                   \EnumT{\red{[}\Econd{}{}{}\red{]}} \red{,} \\
                   \LAM{\V{ty}}
                   \bigRedBracket{
                   \begin{array}{l}
                   \DProd{\DVar{\Ebool}}{\DProd{\DVar{\V{ty}}}{\DVar{\V{ty}}}}
                   \end{array}
                   }
                 \end{array}
                 }
}\]

The resulting data-type is called $\HExprFreeD$. By a simple unfolding
of definition, we note that $\FreeIMonad{\HExprFreeD}{\Ty}{\Val{}}$
corresponds to the syntax of closed terms, $\HExprD$. Similarly,
$$\FreeIMonad{\HExprFreeD}{\Ty}{(\LAM{\V{ty}} \SUM{\Val{\V{ty}}}{\Var{\V{dom}}{\V{ty}}})}$$
corresponds to expressions with variables, $\HExprVarD{\V{dom}}$.

\begin{wstructure}
    /> On open terms, we get a substitution
        -> Apply substI on assgnmt
            -> Have a well-typed language
            -> Get a safe evaluator 
                <- for well-typed terms 
                <- in well-typed contexts
\end{wstructure}

The evaluator for closed term we implemented in
Section~\ref{sec:idesc-examples} remains unchanged. It reduces closed
terms in $\FreeIMonad{\HExprFreeD}{\Ty}{\Val{}}\: \V{ty}$ to values in
$\Val{\V{ty}}$. We are therefore left with implementing $\substH$. We
simply have to fill in the right arguments to $\substI$, the type
guiding us:


\[\stk{
\substH\: \V{dom}\:
          \gammaNat\: \gammaBool\:
          \V{\sigma}\: 
          \V{ty}\: 
          \V{term} \mapsto  \\
\;\;\ \begin{array}{ll}
       \substI\: & \Ty\: 
                  (\SUM{\Val{}}{\Var{\V{dom}}{}})\: 
                  \Val{}\:
                  \HExprFreeD\:  \\
                &
                  (\V{\sigma}\: \V{dom}\: \gammaNat\: \gammaBool)\:
                  \V{ty}\:
                  \V{term}
      \end{array}
}\]

Hence, we have completed our implementation of the evaluator for open
terms. We started with a well-typed language of arithmetical
expressions. We have seen how to take advantage of indexes to define
type-safe constructors. Then, we have implemented an evaluator for
closed term, based on the generic catamorphism function. Having built
an open term representation, we wanted a substitution operation, in
order to close open terms in a context. Again, we have implemented
this operation with the generic substitution operator. Hence, without
much efforts, we have described the syntax of a well-typed language,
together with its semantics.

\begin{wstructure}
<- IDesc
    <- Another instance of free monad
        <- Var: Return
        <- Remaining: (not even indexed) functor
    -> Madness just starts
        <- map operation
        <- [ subst sigma D ] X = [D] (\x -> [subst sigma x] X)
        ???
\end{wstructure}

\paragraph{Indexed description:}

Another instance of free monad is $\IDesc{\!}$ itself. Indeed,
$\DVar{\!}$ is nothing but the \return. The remaining constructors are
simply the pattern functor, trivially indexed by $\Unit$. Hence, we
describe this functor by the following code:

\[\stk{
\IDescFreeD : \PI{\V{I}}{\Set} \IDesc{\Unit} \\
\begin{array}{@{}ll}
\IDescFreeD~\V{I} \mapsto \DSigma{\!}{\!} & (\EnumT \red{[}
                                              \DConst{\!},
                                              \DProd{\!}{\!},
                                              \DSigma{\!}{\!}, 
                                              \DPi{\!}{\!}
                                                    \red{]}) \\
                                  & \bigRedBracket{\begin{array}{l}
                                        \DConst{\Set}               \\
                                        \DProd{\DVar{\Void}}{\DVar{\Void}}  \\
                                        \DSigma{\Set}{(\LAM{\V{S}} \DPi{\V{S}}{(\LAM{\_} \DVar{\Void})})} \\
                                        \DSigma{\Set}{(\LAM{\V{S}} \DPi{\V{S}}{(\LAM{\_} \DVar{\Void})})}
                                    \end{array}}
\end{array}
}\]

Then, we get $\IDesc$ by building its free monad:

\[\stk{
\IDescD : \PI{\V{I}}{\Set} \IDesc{\Unit} \\
\IDescD\: \V{I} \mapsto \FreeIMonad{\red{[}\IDescFreeD\red{]}}{\Unit}{\V{I}}\: \V{I}
}\]


